Ultimate Csharp Masterclass Krystyna Ślusarczyk
Section1:
https://docs.google.com/document/d/143KZel4EeLloysAVyhR0rmdirHnsTDPleRWrxo0jJEs/edit?usp=sharing
Section2:
https://docs.google.com/document/d/1chi9W7E0tHe1gN2undJdpyvO3BVUDmzfYjoKEnPOQew/edit?usp=sharing
Repository:
https://github.com/KrystynaSlusarczykLearning/UltimateCSharpMasterclass

Section2:
Obj folder stores intermediate build artifacts and incremental compilation data for all changed files.
Asp.net To speed up builds during debug or development, modify the project file (.csproj) to disable nonessential build steps such as Razor precompilation and analyzers.

Variables:
Shortcut: Ctrl+D duplicates the line
Multiline Comment: ctrl+shift+/   (ctrl+k+c to comment and ctrl+k+u to uncomment)
Format: ctrl+k, ctrl+d

Implicitly typed variable: var 

REPL (Read Eval Print Loop similar to jshell)
dotnet tool install -g csharprepl
csharprepl
    Gets into interactive mode

C# is a statically typed programming language
int x= 10; x="hello"; not allowed

Convert.ToInt32 vs int.parse
    Convert.ToInt32 accepts null, string, double values if its not overflowing
    int.parse excepts the param to be string
    However int.TryPase is efficient handles all cases

switch case
switch(str) {
    case "fruit":
    case "Fruit":
     Console.WriteLine("Its a fruit");
     break;
    case "Vegetable":
     Console.WriteLine("Its a Vegetable");
     break;
    default:
      Console.WriteLine("Its not a fruit or Vegetable");
     break;
}
Switch Expression
var result =  str switch {
    "fruit" or "Fruit" => "Its a fruit",
    "Vegetable" => "Its a Vegetable",
    _ => "Its not a fruit or Vegetable"
};
Console.WriteLine(result);


MultiDimensional Array
char[,] = new char[2,3];  (Two rows 3 columns)
char[,] char2DArray = new char[,] { {'A','B','C'}, {'D','E','F'} };
Get rows => char2DArray.GetLength(0);  Get columns => char2DArray.GetLength(1);

VariableNames:
@string allowed
1name NOT allowed 
int NOT allowed
first&name NOT allowed

Object Oriented programming (OOP) - Based on concept of objects that contain data and methods.
Objects hold data and behaviors (methods), while a class serves as the blueprint from which those objects are created.
OOP relies on fundamental concepts Encapsulation, Polymorphism, Abstraction and Inheritance 

AccessModifier: public, private, protected, internal
protected: 
    public class Animal { protected string MakeNoise() => "Roar"; }
    public class Tiger : Animal { }
    new Tiger().MakeNoise(); compiler error method MakeNoise() can be accessed only inside Animal or Tiger object not outside.
DateHiding: Using AccessModifier like private and hiding its accessibility outside class

Init:  public int Count {get; init;}
    Property setter modifier, allows the value to be set only in constructor or object initialization

TopLevel statements:
Starting with .NET 6, the Program.cs file uses top-level statements, which hide the explicit Program class and Main() method.
You can restore or override this behavior by adjusting the project settings.

MethodNames: Start with Verb and End with Noun

Encapsulation vs Hiding
Encapsulation = wrapping data + behavior
Data hiding = controlling access to that data (using access modifiers private)

MethodOverloading
    Methods that have the same name but differ in parameter types, number of parameters, or the order of parameters.
Constructor MethodOverloading
    Appointment(string name, string days){}
    Appointment(name):this(name, 7) {}  // here a constructor is calling another constructor

Expression vs statements
Statements doesn't return a value; eg; Console.WriteLine("hello world")
Expression that returns a value public int Add(int a, int b){return a+b;}
Expression Bodied Members: Used when a method, property, or other member consists of a single expression instead of multiple statements.
    public int Add(int a, int b) => a + b;

Optional parameters:
    Methods can have optional parameters but has to be compile time constant 
    public void MakeAppointment(string name, int day=7) - allowed
    public void MakeAppointment(string name, int day=GetDays()) - NOT allowed

nameof
    returns the variablename as string 
    class Person {public string Name;}  -> nameof(Person.Name)

Const (Constant) and Readonly
Const: Used on variable that has compile time constant (PascalCase) 
    example: public const double Pi = 3.14159;
readonly: Variables that can be initialized on declaration or in construtor CANNOT be used in constructors
   example: public readonly int InstanceId = 1; or public class Instance { public Instance(int instanceId) { InstanceId = instanceId;  } }    
Casing: const → PascalCase  |  readonly → camelCase (private) or PascalCase (public) 

Static:
    Used on methods that are stateless
    Static class can have only static Members, it can have parameterless constructor which executes once and is private by default
    Instance class can have both Static and Instance members

String Join Split
    String.Join(",", strArray) => results in a string
    str.Split(",")  => results in an array, splits string with the delimiter


Single Responsibility Principle: A class that has only one reason to change. 

DRY principle (Dont Repeat Yourself) states that we shouldn't have multiple places in the code where the same business decisions are defined.

GlobalUsings
Namespaces defined in GlobalUsings.cs available for all classes (optionally you can define them in the project file)
                                <ItemGroup><Using Include="System" /><Using Include="System.Collections.Generic" /></ItemGroup>
Globalalias
    global using IO = System.IO;

Enum
    An enum (short for enumeration) is a special value type that lets you define a set of named constants — typically used to represent a fixed group of related values.
enum ErrorCode { None = 0, NotFound = 404, ServerError = 500 }

Inheritance (is-a relationship)
    public class Car {} public class Honda:Car {}  //Honda is a Car

Overriding
Derived class can override Base class methods provided the base class method is declared virtual
    class Animal
    {
        public virtual void Speak()  {        Console.WriteLine("Animal sound");     }
    }
    class Dog : Animal
    {
        public override void Speak() { Console.WriteLine("Bark");        }
    }    

Animal a = new Dog();
a.Speak(); //output: Bark

Shadowing or Hiding
Derived class hides Base class method by using "new" each has its own implementation 
    class Animal
    {
        public void Speak()  {        Console.WriteLine("Animal sound");     }
    }
    class Dog : Animal
    {
        public new void Speak() { Console.WriteLine("Bark");        }
    }
Animal animal = new Dog();
animal.speak(); //output: Animal sound        

Diamond Problem in Inheritance:
When a class inherits from two or more classes that share a common ancestor, creates a Diamond shape hierarchy. Ambiguity arises if a method is derived in the intermediate classes, end derived class doesn't know which one to use.

System.Object is the baseclass for all classes 

Constructor:
    Derived class instantiation always calls Base class constructor first. 
    Animal{Animal(int legs){} }  Cat:Animal { Cat(int legs) : base(legs) {} }

Explicit Conversion:
    decimal (0.01m) and double are floating point types. decimal has more precision (used in banks) double has less precision (used in scientific calculation)
    decimal is 128bit and double is 64bit
    decimal uses base10 wheras double uses binary. What does it mean 0.1+ 0.2 in double leads to 0.30000000000000004 whereas in decimal it gives 0.3 (precision)
    double is faster as its a native type to CPU, decimal is a software emulated type.
    implicit conversion int x = 2; decimal d = x; 
    decimal d = 0.01m; int x = d; (not possible as there is a loss), so we do => int x = (int)d;

    enum season {spring, summer, autumn, winter} int x= 11;
    season s = (season)x;  Here explicit conversion should fail but doesn't. Should be cautious when using explicit
    For int types, (Enum.IsDefined(typeof(season), x)) For string types, Enum.TryParse()
    
    UpCasting DownCasting
    Animal:Cat Animal:Dog 
        Animal a = new Dog(); this is upcasting derived class assigned to a base class
    Animal a = new Dog();
    Dog = a; This is downcasting, but not safe what if Animal holds Cat instead of Dog

    "Is" Operator
        Animal a = new Dog(); a is Dog ? returns true;
    "Is" Assignment
        List<Dog> dogs;
        if(a is Dog x){ dogs.add(x);}  //Here a is Dog does type check followed by variable makes assigment to variable x; 
    If you wonder why can't I just add dogs.add(a); instead of dogs.add(x) first one does casting to Dog, whereas second doesn't do casting
    Here does safe type check if(a is Dog x) another alternative way
        newList.Add((TTarget)Convert.ChangeType(item, typeof(TTarget))); //not type safe

    "As" Operator
    Animal a = new Dog();
    Cat c = (Cat)animal - Standard cast Expression it will throw Invalid CastException due to incompatible types
    Cat c = animal as Cat - as cast Expression, returns null instead of exception

Abstract class
    Class that cannot be instantiated but can be derived from it. Its not must for an abstract class to have abstract methods.

Sealed class:
   sealed class Vehicle, disallows deriving from this class.

Sealed method:
    sealed method disallows futher overridding 
    class base {virtual void show(){}}  class derived { sealed override void show() {} }  class subderived { //cannot overrider show further here}
    Static classes are implicitly sealed

Extension method:
    Add a method to an existing Type without modifying the actual type
    example: public static class StringExtension { public static string NewSting(this string s) { return s; }}
    Index in list -> List<int> intList = new List<int> {1,2,3,4,5,6}; intList.Where((value,index) => {});

Interface:
 Its a contract, defines what a class must do, but not how it does it.
 From C#8 allows default method implementation
 interface ILogger { void Log(string message); void LogError(string message) { Log(message);  }  } This way in a setup where classes that already inheriting from the interface, adding default implementation to the interface won't break other classes.
 interface inheritance is idempotent, meaning if the same interface appears more than once in the inheritance chain, compiler treats it as one.
 A class can inherit from multiple interfaces, but only one class concrete/abstract class

Target typed new expression (available from C# 9)
Class1 c1 = new (); (equivalent to Class1 c1 = new Class1())

Dependency Inversion Principle: 
    High level modules should not depend on low level modules, both should depend on abstractions. OrderService -> IQuoteService  <- QuoteService

typeof(Compile time) vs GetType (RunTime on an instance)
typeof("hello") -> System.String
person.GetType()


UML:
Aggregation
	Aggregation example: (Here dependency Professor is injected and mapped to a class level field (or property)
	class Department{
		private Professor _professor;
		Department(Professor professor){
			_professor = professor;
		}
	}  
	Definition: Aggregation a week whole-part("has-a") relationship, UML: ◇—— hollow Diamond Arrow pointed at Depender. Aggregation: Department ◇—— Professor. Why weak when Department disposes still Professor exists

Composition
	Composition example: (Dependency Professor is created within Depender)
	Class Department {
		private Professor _professor;
		Department(){
			_professor = new Professor();
			}
		}
	Definition: Composition, a strong whole-part ("owns-a") relationship, Solid Diamond Arrow pointed at Depender Composition: Department ◆—— Professor. Why strong when Department is disposed Professor is disposed as well
Association
	Assocation example: (Here dependency Professor is used, but not mapped to any field/property as class level
	class Department {
		public void Teach(Professor professor){}
	}
	Definition: Association ("uses-a") Professer object, Solid line Arrow Pointed at Dependency. Department ———> Professor.
Generalization (Inheritance)
    Generialization example, Maths "is a" Department
    class Maths: Department {}
    Definition: Generialization, there exists "is a" relationship between child(Maths) and parent(Department) UML: Maths ─────▷ Department (triange arrow head)


Exception and Error Handling
3 Types: Compile time errors , RunTime errors and Logical errors
Exception base class is System.Exception, all other excpetion types derived from System.Exception
Known exception types: ArgumentException: {ArgumentNullException(eg: input null), ArgumentOutOfRangeException(eg weekday input: 8)}, InvalidOperationException(input collection is empty)
StackOverflowException:
    RecursiveMethods:  if there is method calling itself this could be result in StackOverflowException
throw ex vs throw (throw ex is bad practise)
a)
        Method1(){
            try{
                Method2();
            }
            catch(NullReferenceException ex) {
                //ex.stacktrace shows Method2 when throw ex was performed in Method1 as it resets the stack trace;
                //ex.stacktrace shows Method1<-Method2 when throw was performed 
            }
        }
        Method2(){
            try{
                throw NullReferenceException("object is null");
            }
            catch(NullReferenceException ex){
                throw;
                //throw ex; //bad practise as it resets the stack trace
            }
        }
b) Pass ex (original exception) while throwing -> throw new ArgumentNullException("The collection is null", ex);
 Method1(){
            try{
                Method2();
            }
            catch(NullReferenceException ex) {
              //Here ex.Message shows "The collection is null"
              //ex.StackTrace points to the place where its thrown here its -> throw new ArgumentNullException("The collection is null", ex);
              //ex.InnerException shows "Object Reference not set.... because while doing throw new, ex is passed as second param.
              //ex.InnerException.StackTrace points to the root (origin) of exception -> throw NullReferenceException("object is null");
              
            }
        }
        Method2(){
            try{
                throw NullReferenceException("object is null");
            }
            catch(NullReferenceException ex){
                throw new ArgumentNullException("The collection is null", ex);
            }
        }
Exception filter: catch when (ex.Message.StartsWith("400")) {}
 Catch block condition (when) allows conditionally catching exception

Shortcut:
ctrl+Shift+Space: shows available overloads for a method/constructor...
    File.ReadAllLines() (place the cursor inside the parenthesis and press ctrl+shift+space)

CustomException:
    Derives from Exception class, 
    [Serializable]  //optional
    public class CustomException : Exception
    {
        public string Data {get;}
        // 1️⃣ Default (parameterless)
        public CustomException(): base() { }
        // 2️⃣ Message-only
        public CustomException(string message) : base(message) { }
        // 3️⃣ Message + inner exception 
        public CustomException(string message, Exception innerException) : base(message, innerException) {  }
        // 4️⃣ Message + inner exception + Data 
        public CustomException(string message, Data data, Exception innerException) : base(message, innerException) {this.Data = data; }
        // 5️⃣ Serialization (for remoting or custom serialization) //optional
        protected CustomException(System.Runtime.Serialization.SerializationInfo info,
                                System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
    }
If your exception may be serialized or re-thrown across application domains or process boundaries,
then you must include the serialization constructor (the 5th one). Its legacy way not needed

If your code uses reflection, DI frameworks, or rethrow logic that assumes exceptions can be created dynamically, a parameterless constructor helps those frameworks instantiate your exception safely.    

Generic types:
    IEnumerable<T>
        ↑
    ICollection<T> : IEnumerable<T>
        ↑
    IList<T> : ICollection<T>, IEnumerable<T>
        ↑
    List<T> : IList<T>, ICollection<T>, IEnumerable<T>
DataStuctures: Are types meant for storing and organizing data so that it can be accessed and modified efficiently.    
Examples of DataStructures: 
Linear: Arrays, List, LinkedList, Stacks, Queues
Non-Linear: Tree, BinaryTree, Graph
Hash-Based structures: Dictionary, HashSet
Specialized Structures: PriorityQueue, Tuple/Record

List uses Array under the hood for datastorage. When items added to the list, Array is resized(doubled default is 4, next time it will become 8). 
And when items are removed, size is not shrinked unless explicitly called list.TrimExcess()
    Sample: Refer CodeSnippets.txt #CustomGenerics

Simple generic type: refer CodeSnippets #SimpleGenericType

Tuple
    A lightweight data structure to group multiple data elements into a single object without the need to create custom class or struct
Implicit named Tuple: example: var person = ("John",20)    // person.Item1 contains John
Named Tuple: (string name, int age) person = ("John", 20) // person.name contains John

Generic Method:
Class can be non-generic but its methods can be generic
Refer: CodeSnippets #GenericMethod   

Type constraint:
    i) Limits types to be used for Generic type that parameterless constructor
    IEnumerable<T> RandomCollectionGenerator<T>(int maxLength) where T: new() { // where T:new() ensures T types should be classes only that have parameterless constructor 
        var randomLength = Random.Next(maxLength+1);
        var result = new List<T>(randomLength);
        for(int i=0;i<randomLength;i++){
            result.Add(new T());
        }   
    }
    ii) Limit specific types for the Generic Type 
    public class Person{public int Year {get;set;}} public class Employee: Person {}
    public IEnumerable<T> GetValid<T>(IEnumerable<T> input) where T: Person {
        List<T> validOnes = new List<T>();
        foreach(var item in input){
            if(item.Year > 1900 && item.Year < DateTime.Now.Year)
                validOnes.Add(item);
        }
        return validOnes;
    }

List creation with size
    If we know the size, initialise list with size, otherwise list has to resize internal array (4,8,16,32...)
    new List<int>(size); 

Time Consumption (performance measurement)
    StopWatch stopWatch = StopWatch.StartNew();
    MethodCall();
    stopWatch.Stop();
    stopWatch.ElapsedMilliseconds // gives the time consumed by method

Invariant: You cannot substitute one generic type argument for another, even if there is inheritance relationship between those types Refer: #Invariant

Covariance is required when a generic interface (or delegate) should allow a derived implementation that uses a derived type argument to be assigned to a base interface reference that uses the base type argument.
    Covariance allows a generic interface to safely substitute a more derived type (Dog) where a base type (Animal) is expected.
    This works only if the interface is a producer of the generic type (returns T, never accepts it).
    The out keyword on the interface makes this possible.
    As a result, PrintAnimals works with both dog and cat providers.
Refer: #Covariance

Contravariance is the opposite of Covariance. Refer: #Contravariance

IComparable interface lets compare two objects. In this comparison, we compare two objects based on a property
Refer: #IComparable

Type Constraint - numeric types.
Use the INumber interface lets perform math operation (square) on generic types
 public static T Square<T>(T t) where T : INumber<T> => t * t;

Func Action Delegates
    Func is a generic delegate type that represents a method which returns a value;
    Action is a built-in delegate type in C# that represents a method that does not return a value
    Note: Func<int,bool>, you can use Predicate here -> Predicate<int> (it returns bool)

Lambda Expression: Inline anonymous method
    Anonymous methods: (parameters) => expression
Expression vs Statement:
    Expression evaluates to a value x+y 
    Statement performs an action: Console.WriteLine("HelloWorld"), int x=5, x++;

Delegate: Type whose instances hold a reference to a method(methods), declaration looks similar to method declaration.
delegate string ProcessString(string input);
Multicast delegate references multiple methods, via delegate instances in its invocation list.
refer #delegates

event: 
Event facilitates publisher subscriber pattern. Say you have a TravelVideosChannel and subscribers subscribed to it. When a new video is published 
they will be informed(event published). 
refer: #event



Dictionary: (DataStructure)  Generic Collection of KeyValue pairs (HashTable -Legacy non generic)
    Allows quick lookup a value based on its key. Keys must be unique.
How Dictionary achieves quick lookup ?
    Dictionary internally has buckets of memory, it will store the key in one of the bucket. When you store a key -> gets the hashcode of the key ->
    say 12345 ->  Assume Dictionary has 5 buckets -> Now bucketIndex = HashCode % No. of buckets -> 1234/5 = 4. It stores the key in bucket 4. During retrieval using the 
    hashcodeOfkey % NoOfBuckets finds the bucket to find the value.
 ContainsKey checks whether the keys exists in the Dictionary

 Strategy Design Pattern- Behavioral pattern(Gof-GangOfFour)
    The behavior of a class can be decided at runtime when the abstraction it depends on is associated (or injected) with a concrete derived implementation.
    Its an implementation of Open/Closed Principle in SOLID design principle
    Refer: #StrategyDesignPattern

Decorator pattern - Behavioral pattern
    Adds new behavior or features to an existing object without changing its code. Lets say initially you had only EmailNotifier for INotifier, later when you want to extend for SMS
    and Slack as below, here we decorate/wrap additional objects to achieve it. Idea is each hold reference of predecessor initialized in the constructor. When the send method called 
    it calls base.Send() first. Refer #Decorator Pattern
     services.AddTransient<INotifier>(sp =>
        {
            INotifier n = new EmailNotifier();
            n = new SMSNotifier(n);
            n = new SlackNotifier(n);
            return n;
        });

Class vs Struct
    Class is a reference type.
    Struct is a value type. It can be made immutable public readonly struct Coordinates { int x; int y; }
    Struct when copied it, it copies whole no references. (Struct s1=s2;) Except if you modify a reference type of Struct it gets affected both places. However if the reference type is reinitialized 
    it will affect only on the struct where its done.
    Refer: #ClassVsStruct

LINQ: (Language Integrated Query)  - Allows simple and efficient querying over different kinds of data.
    It allows filtering, ordering and transforming the collection elements
Spread/Collection Operator: Creates an immutable fixed array/list based on inferred type. Its used in a Collection expression ([...]) to expand(spread) the elements of another collection
into the new one.
example:  
          old approach: return words.Where(word => word.ToUpper() == word).ToList(); //slight performance overhead as it doesn't create a fixed immutable collection  
          return [.. words.Where(word => word.ToUpper() == word)]; //returns List<string> if the method return type is list<string>
          return [.. words.Where(word => word.ToUpper() == word)]; //returns string[] if the method return type is string[]
          var capitalizedWords =  [.. words.Where(word => word.ToUpper() == word)]; //NOT ALLOWED, as the expression doesn't what target type to infer
          string[] capitalizedWords =  [.. words.Where(word => word.ToUpper() == word)]; //Allowed as Target Type string[] is explicitly stated
Refer: #Spread          

LINQ Methods
All ->  words.where(word => word.All(l => char.IsUpper(l)));
Any -> Checks if any of the item in the collection matches the condition 
All -> checks all the items in the collection matches the condition
Count -> Counts the items matching the condtion. pets.Count(pet => pet.Type == PetType.Dog);
LongCount -> Used when the output count (long) is larger then Count ouput (int)
Contains -> Checks if an item is present in the collection. var numbers = new[] {1,2,3,4}; numbers.Contains(4);
OrderBy (ThenBy) -> OrderBy orders elements in the collection by a Key also allows further ordering using ThenBy refer: #OrderBy
First -> Returns the first element in the list (uses predicate when supplied) numbers.First(number => number%2==0);
refer: #OrderByWithFirst
FirstOrDefault -> If there is not first item returns the default value of the type.
Last -> Returns the last element in the list (uses predicate when supplied)
LastOrDefault -> If there is not last item returns the default value of the type.
Where -> Applies filter on a collection, numbers.Where(number => number%2);
Where-With-Index -> Along with predicate you can supply index position in the collection eg) animals.Where((a, index) => index % 2 == 0); 
Refer: #WhereWithIndex
Distinct -> Gets the unique elements in the collection
Select -> Takes the input sequence and projects(maps) into a Different Anonymous Type or get a Subset of properties, animal.Select(a => new {a.Type}); animals.Select((a, index) => new { index, a.Type });


char.IsWhiteSpace checks for " ", "\n", "\t", Its unicode aware correctly checks for whitespace from other languages

Method syntax vs Query syntax
    Method syntax: var evenNumbers = numbers.Where(n => n%2 == 0);
    Query syntax: var evenNumbers = from number in numbers where number%2 == 0 select number;

Lazy vs Eager evaluation
public IEnumerable<string> GetWordsGreaterThanLengthTwo() =>
    return words.where(word => word.Length > 2); --> Lazy evaluation, returns an Iterator object(IEnumerable<string>) that performs filtering only caller enumerate it(foreach) Deferred execution.
    return [.. words.where(word => word.Length > 2)]; --> Eager evaluation filtering is done before returned
    return words.where(word => word.Length > 2).ToList(); Eager evaluation as well

Linq Method chaining
    numbers.Where(number => number%2 == 0).OrderBy(number => number);

Most of the Collections implement IEnumerable, thus LINQ querying possible on them


.Net under the hood: (C# is a plane, .Net is the airport)
.Net compatible programming languages
F#- Functional programming language developed by Microsoft
IronPython - .Net compatible version of Python
Visual Basic

.Net frameworks
Windows Forms, Windows Presentation Foundation (WPF), ASP.Net MVC, .Net MAUI (Mobile apps)

.Net Framework released in 2002
.Net Core released in 2016
.Net Core 5.0 released in 2020 -> Referred as .Net 5

Intermediate Lanaguage (CIL)
When the code is compiled, Roslyn compiler compiles to IL code
JIT (Just in Time compiler) further compiles to Binary code specific to the machine

CLR (Common Language Runtime)
    Runtime environment that manages the execution of .Net apps. Note: Manages only the Managed Code (Not COM apps)
        Application <-> CLR <-> Operating System
Reponsibilities: Just-In-Time Compilation, Memory Management, Error Handling, Thread Management

Stack vs Heap
Stack is used for Value Types is created per Thread (Size around 4MB), gets automatically removed when not in scope.
Heap is used for Reference Types is created per App (Size: large), gets cleaned by Garbage Collector

DateTime is a struct value type, internally its just a 64 bit long variable that gets to transformed to DateTime struct.

Best Practices: 
Never modify the input object of a method parameter  PrintPerson(Person person) { person.name = "john"; } // don't do that. To stop this you can make the properties immutable(init) public class Person { public string Name {get;init;} }

ref modifier: (argument passed to method by reference)
    Method parameter with ref modifier, changes to it within in the method, will be available(reflected) to the caller as well
    var y = AddNumber(5); now y holds 6 public void AddNumber(int x) => ++x;
out modifier: Method with out param, needs to be set value inside the method 
public void Add(out int x) => x=1;  when method Add called x may or may not be initialized, but the method that holds out on the argument should set some value.

Reference Type:
    var list = new List<int> {1,3,4,5}; AddOneToList(list); Now the list holds 1,3,4,5,6
    void AddOneToList(List<int> list){ list.Add(6); }
Important note that,
    var list = new List<int> {1,3,4,5}; AddOneToList(list); Now the list still holds 1,3,4,5  it didn't become null because variable list previously pointed to an Address, not its just got set to null.
    void AddOneToList(List<int> list){ list = null; }

Boxing Unboxing
Boxing(value->reference implicit): Boxing is the process of boxing an value type as object type in Heap, below when you assign valueType x to object obj a reference type, it creates a object that will hold the value type value implicitly
In another words, Boxing is implicit mechanism of assinging value type to reference type
    int x = 5;
    object obj = x;
Unboxing(reference->value explicit): Converting the Value type to Reference type
Object obj = 1;
int x = (int)obj;

Boxing is expensive as you box the value type it holds more memory
List<int> list = new List<int> {1,2,3,4,5};
ArrayList list = new ArrayList {1,2,3,4,5 }; //expensive as the ArrayList holds int as objects

Garbage Collector:
    Heap memory management mechanism is called the Garbage Collector (GC), its part of CLR. It helps in removing unused objects from memory.
    Runs on a background thread.
Trigger:
    When Operating System(OS) signals CLR that is has little free memory left.
    When the amount of memory occupied by objects in the heap surpasses a given threshold.
    When you call GC.Collect() method.
Memory Defragmentation: Process of moving objects in memory to create a bigger block of free memory.

How GC removes objects from Memory ? It uses Mark-and-Sweep algorithm
Garbage Collector builds a graph from the root of the object, if an object doesn't have reference its skipped in the graph, means the objects not part of the graph can be removed from memory.

Garbage Collector Responsibilities:
Identify objects that are no longer needed
Removing those objects from memory
Defragmenting the memory

Generation of objects:
Garbage Collector divides objects into 3 generations 0,1 and 2 (0-short lived, 2-long lived). An object from generation 0 that survived the collection(during garbage collection object still has reference and used)
then the object gets promoted to generation 1, after that to generation 2. Garbage collect doesn't check generation 2 objects often assuming they survived(had reference and in use) in multiple rounds 
so its likely still in use.

Memory leaks: A situation when some piece of memory is not being cleaned up, even if the object is no longer in use.
Garbage Collector does not give us 100% protection from memory leaks.
One of the most common sources of memory leaks in .NET is related to events.
Other reason is static fields.
    Static fields act like global variables.
    As long as the application lives, the GC considers static references alive, so their objects are never collected.
    If those objects reference large graphs (collections, event handlers, etc.), memory stays allocated indefinitely.
    refer: #StaticMemoryLeak

Finalizers (destructors)
    Finalizers are called when the Garbage Collector decides to collect the objects
    public class Person {
        public void Dispose()
        {
            if (!disposed)
            {
                //Connections.Close();
                disposed = true;
                GC.SuppressFinalize(this); 
            }
        }
        ~Person(){
        //do something
        }
    }
    GC.Collect() is calling to explicitly trigger Garbage collection.
    GC.SuppressFinalize is called to cancel Garbage collection.

Dispose:
    Dispose releases unmanaged resources and performs cleanup for managed resources that need explicit cleanup (such as closing streams, flushing buffers, or releasing handles).(managed resources: managed by CLR, unmanaged resources: database connections, file handlers, open network connections)

StreamWriter:
 Creates and writes data to file. Note writes are buffered as in the option1 meaning file created but the data line1, line2 not written it waits for command streamWriter.Flush() to get it written to file. 
 Option2 is recommended as it does the flush of data and object disposal(streamWriter.Dispose()) as well. Internally Close calls Dispose Close() → Dispose() → Flush() + release stream
Refer: #StreamWriter


IDisposable allows a class to deterministically release unmanaged resources and to clean up managed resources that require explicit cleanup (such as flushing buffers or disposing streams).”
using(var fileWriter = new FileWriter()) -> using to cleanup managed resource allowed only when the object implement IDisposable interface
    public class FileWriter: IDisposable
    {
        private StreamWriter _streamWriter;
        public void Write(string message)
        {
            _streamWriter.WriteLine(message);
        }

        public void Dispose() { 
            _streamWriter.Dispose();
        }
    }

Advanced C# types
Reflection: Runtime inspection enables metadata access(class properties, constructors, access modifiers) and allows method invocation. Here from obj (of Human class) we are getting the properties
    Object obj = new Human("John", 25);
    Type type = obj.GetType();
    var properties =  type.GetProperties().Where(prop => prop.Name != "EqualityContract");
    var values = properties.Select(prop => new { prop.Name, Value = prop.GetValue(obj)?.ToString() }); 
    
    Output: Error: Animal1 ph has an invalid length of 2

Attributes can additional meta data to existing class. Attribute constructor allows only simple types, bool, string or numeric types, enums (eg. List<string> not allowed)
Refer: #Attributes
     
Struct: (struct -> System.ValueType -> System.object)
Struct is a value type. It follows value semantics meaning the value of a variable is modified only through the variable itself, example below.
    struct Point
    {
        public int X { get; set; }
        public int Y { get; set; }
        public string Name { get; set; }
        public Point() { }
        public Point(int x, int y, string name)
        {
            X = x;
            Y = y;
            Name = name;
        }
        public override string ToString() => $"x:{X} y:{Y} name:{Name}";
    }

var point1 = new Point(1, 2, "Sunny");
var point2 = point1;
point2.Name = "Phoebe";
Console.WriteLine(point1.ToString());  //x:1 y:2 name:Sunny
Console.WriteLine(point2.ToString());  //x:1 y:2 name:Phoebe

Structs vs classes
Structs are not nullable as Classes are, 
    Struct Person {} -> Person person = null; //not  allowed
    class Person {} -> Person person = null; //allowed
Structs are sealed, meaning it cannot be derived, but it can derive from an interface. struct Person : IComparable<Person>
Structs allow to create instance even when there is no Parameterless constructor. struct Point { public Point(int x, int y) {}  } you can still call Point point = new Point(); (which couldn't be done in a class)
Structs cannot have finalizers. Reason say DbConnectionStruct: IDisposable { private IDbConnection _dbConnection;  ~DbConnectionStruct() {  Dispose();} public void Dispose() {_dbConnection.close(); }  } Now just imaging the DbConnectionStruct is passed as param to a method, then a different copy 
is passed to method when the method completes struct is diposed and the _dbConnection is gone, and the calling method if it tries to make db task it would fail as its already closed.
Struct cannot have cycle. Struct Point { public Point Point1 {get;} } since stack is small size, if its allowed it can grow large hence not allowed.

When to use Struct instead of Class
If there is a need for ValueType semantics store coordinates.
Equality checking, struct Point {int x; int y;} Point p1 =new Point(1,2); Point p2 = new Point(2,1); if you check p1==p2 it checks the values of the property (not the case in class as it compares references)

struct should be immutable as its a value type, when you copy it to another variable for example, modifying the copied to variable doesn't change the original variable. so Struct properties be Name {get; init;}

with expression, allows produces a new struct allowing to modify properties, with can also be used for record and anonymous types but not for classes
Point p1 = new Point(1,2); -> Point p2 = p1 with {x=2}; (note: properties should have either init or set accessor)

Explicitly making struct immutable (so someone doesn't accidentally use set on property instead of init or get only)
readonly struct Point { public int X {get; set;}  } here with set accessor it will fail its readonly

object.ReferenceEquals() checks if two object holds same references you can do p1 == p2 if the object doesn't have operator overloading
Operator overloading 
    public static bool operator ==(Person a, Person b)
    {     return a?.Name == b?.Name;   }

Equals checks values for ValueTypes (struct)    
Equals checks references are equal for Reference types

Overriding Equals in Class
    public override bool Equals(object? obj){
        return (obj is Person other && Id == other.Id);   //here if the obj is Person it gets typecasted to other variable
    }

Overriding Equals in Struct (By default Equals compares all values, we override it as Struct Equals compares all values by using Reflection causing performance issue, we can override to compare specific values)
    public override Equals(object? obj){
        return obj is Point other && X == other.X;
    }

But notice above method Object involves Boxing/Unboxing since Struct is value type. To avoid this, you can use below and implement IEquatable<Point>
    public bool Equals(Point point){
        return X == point.X;
    }
Note: Contains method used IEquatable interface    
Refer: #Equals    

Implicit and Explicit Conversion operator
int i = 100; decimal d = i; (here implicit conversion involved)
but if you do decimal d = 25.12m; int i= (int)d; (explicit conversion involved with possible data loss)

Lets say you have a Struct with x, y properties, Pointer pointer = (5,6); (assigning a tuple to pointer) its possible only when you define the implicit operator 
Refer: #implicitoperator

Hash function: One way cryptographic functions that maps an input of any size to an output of fixed length of bits.
Two different objects ideally should have different hash codes, but duplicates may happen (hashcode conflict)
Dictionary uses hashcode of the reference(address) for the Key, so below is not duplicate.
    Dictionary<Person, string> dictionary = new Dictionary<Person, string>();
    dictionary.Add(new Person { Name = "Sunny", YearOfBirth = 1990 }, "Sunny");
    dictionary.Add(new Person { Name = "Sunny", YearOfBirth = 1990 }, "Sunny");

Say you have implemented IEquatable interface with Equals and GetHashCode Refer: #CustomHash
Note: what properties used in Equals (say you have x,y) and in equals only x used for equality check, ensure same is used in GetHashCode
example: public override bool Equals(Person person) => Id == person.Id;
         public override int GetHashCode() => Id; 
example: public override bool Equals(Person person) => Id == person.Id && Age == person.Age;
         public override int GetHashCode() => HashCode.Combine(Id, Age);

This will throw duplicate key exception now 
    Dictionary<Person, string> dictionary = new Dictionary<Person, string>();
    dictionary.Add(new Person { Name = "Sunny", YearOfBirth = 1990 }, "Sunny");
    dictionary.Add(new Person { Name = "Sunny", YearOfBirth = 1990 }, "Sunny");

But it behaves different with struct
var dictionary = new Dicationary<Point, int>(); //Point is a struct
var point1 = new Point(1,2);
dictionary[point1] = 3;
var point2 = new Point(1,2);
Console.WriteLine(dictionary[point2]); //ouput: 3 Note point2 is not added to dictionary, but dictionary returns 3 because in Struct by default the values are checked for equality whereas in 
class by default reference address is checked.

Note: Dictionary keys should be immutable 
Person p1 = new Person("john");
Say Dictionary[p1] = 25; later if you set p1.name="johnny" and then try to get value Dictionary[p1] would fail, because original when Dictionary generated Key for Person p1 it got hashcode for value "john" 
now its changed

ValueTuple:
Below is a reference type tuple stored in heap NOT recommended
    var tuple1 = Tuple.Create("Sunny", true);  or new Tuple<string, bool>("Sunny", true);
Modern ValueType Tuple (struct) stored in Stack is recommended
    var tuple1 = ("Sunny", true);
Reference Type Tuple can contain max 8 items (8th element is another Tuple)
ValueType Tuple has no limitation
By Default objects 
    p1 == p2 returns false as it checks reference equality
    p1.equals(p2) returns false as well it checks reference equality
    var p1 = new Person { Name = "Sunny" };
    var p2 = new Person { Name = "Sunny" };

In case of ValueTypes it behaves different
    var p1 = new Point { X = 1, Y = 2 };
    var p2 = new Point { X = 1, Y = 2 };
    p1 == p2; compiler error as == operator is not available by default
    p.Equals(p2) as it checks for values equality 

Tuple behaves same as ValueTypes except that it supports == operator by default (not the case in ValueType)
    var t1 = Tuple.Create("Sunny", true);
    var t2 = Tuple.Create("Sunny", true);
    t1.Equals(t2) -> true
    t1 == t2 -> false 
ValueTuple, note both Equals and == operator returns as ValueTuples are checked for equality by values.
    var t1 = ("Sunny", true);  
    var t2 = (Name: "Sunny", Flag: true);
    var (Name, Flag) = ("Sunny",true);
    t1.Equals(t2);  // true
    t1 == t2;       // true
Note ReferenceType Tuples are immutable, its items cannot be modified. But ValueType Tuples are not immutable

PureFunctions don't alter the input parameters eg. int Sum(IEnumerable<int> numbers) IEnumerable is immutable type
Immutable types and pure functions are tenets of functional programming. 
Dictionary Keys should be immutable types

Records 
Creates a immutable type with less code and by defaults provides equals, == , GetHashCode, ToString(), and record doesn't use Reflection to achieve this.
Record is a reference type with value based equality and hashcode calculation
Supports inheritance
Below declaration is called Positional Record (without body), and properties can be set only during declartion 
    public record WeatherData1(decimal Temperature, int Humidity); Note: parameter Names are capitalized as they are the public properties, Properties are immutable (internally it has get;init;)
Non-Positional Record you define body as well and you need to explicitly define constructor and properties. (equals, == GetHashCode are generated by default for the Non-Positional Record)
    public record WeatherData {
        public decimal Temperature {get;}
        public int Humidity {get;}
        public WeatherData(decimal temperature, int humidity){
            Temperature = temperature;
            Humidity = humidity;
        }
    }    
refer #Record

Record Structs
Record Structs are value types and mutable (whereas Records are immutable and reference types)
public record struct Rectangle(int A, int B);
To make it immutable add readonly -> public readonly record struct Rectangle(int A, int B);

Nullable value types
    Allow represent null value for value types
    int? height = null; (equivalent to Nullable<int> height = null). 
    example scenario, say you have list of height for people but unsure of heights of certain people, List<int?> heights = new (); heights.AddRange(165,null,125,140); 
    Console.WriteLine(heights.Where(h => h != null).Average());

Nullable reference types
Nullable reference types are a C# compiler feature introduced in C# 8.0 to help prevent NullReferenceException at compile time.
#nullable enable
    string name = null;    // ❌ Warning — non-nullable cannot be null
    string? middle = null; // ✔ OK — nullable
    name?.Length -> returns null when name is null  (Null conditional operator)
    name!.Length -> dangerous null ignore (Null forgiving operator)

Collections:
    IEnumerable
    ↑
    ICollection
    ↑
    IList
Note LINQ libraries many functionalities are simply an extension of IEnumerable interface    
IEnumerable → “This collection can be iterated. I can give you an IEnumerator.”
IEnumerator → “I am the thing that actually does the iteration.”
    string[] words = new string[] { "Sunny", "Phoebe"};
    IEnumerator enumerator = words.GetEnumerator();
    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
    and syntatic sugar equivalent is foreach(var word in words) Console.WriteLine(word);

CustomCollection:
    To implement custom collection inherit from IEnumerable Interface additionally implement IEnumerator from a class that will be used in the Custom collection GetEnumerator
    Class that IEnumerator needs to have Object Property Current that holds the current Pointer in the array, MoveNext increments and checks if the next index available 
    refer: #CustomCollection

Implicit and Explicit interface implementation
When  you implement an interface say inherting from IEnumerable
public class CustomCollection: IEnumerable {
    public IEnumerator GetEnumerator() => return new WordsEnumerator(words);
}
Above returned Enumerator involves object instead of string. To overcome this you want to implement IEnumerable<string>. IEnumerable<out T> also implments IEnumerable, so you have to implement methods from both interface
However you cannot have two GetEnumerator methods with same name one from IEnumerable base interface and other from IEnumerable<string> derived interface
public class CustomCollection: IEnumerable<string> {
    public IEnumerator GetEnumerator() => return new WordsEnumerator(words);
    public IEnumerator<string> GetEnumerator() { throw new NotImplementedException();  }
}
To overcome above duplicate method implementation, you need to explicitly mention the interface (explicit) name -> IEnumerable.GetEnumerator() also notice the access modifier should not be used.
public class CustomCollection: IEnumerable<string> {
    IEnumerator IEnumerable.GetEnumerator() => return new WordsEnumerator(words);
    public IEnumerator<string> GetEnumerator() { throw new NotImplementedException();  }
}
Now, var customCollection = new CustomCollection();  var enumerator = customCollection.GetEnumerator(); calls IEnumerator<string> GetEnumerator()
To call the other method explicit Interface variable, IEnumerable enumerator = customCollection.GetEnumerator(); calls IEnumerator IEnumerable.GetEnumerator()
Refer: #ImplicitExplicitInterface 

Lets say class implements 2 interfaces and both have same method with same signature, implementing one method is sufficient
    public interface IApp { public void Run(); }
    public interface IProcess { public void Run(); }
    public class App : IApp, IProcess { public void Run() { } }
However if you need you can still implement Run methods specific to an interface by explicit interface signature
    public interface IApp { public void Run(); }
    public interface IProcess { public void Run(); }
    public class App : IApp, IProcess {  void IApp.Run() {} public void Run() { } }

Named argument:
Say you create instance while passing values you can name it for readability, new Random(Seed: 1);

Indexers:
An indexer lets an object be accessed like an array using the [] syntax.
    var indexer = new Indexer(new string[] { "Suny", "Phoebe" });
    indexer[0] = "Sunny";
    Console.WriteLine(indexer[0]); //output: Sunny
    
    public class Indexer {
        public string[] _words { get; set; }
        public Indexer(string[] words) => _words = words;
        public string this[int index] {get => _words[index]; set => _words[index] = value;}
    }
Refer: #Indexer    

Collection initializers
    Generics allow initialize classes this way, List<int> ints = new() { 1, 2, 3, 4 };
    To achieve the same for Custom class, inherit from IEnumerable,  add default constructor, add Add Method.
    Refer: #CollectionInitializer

ICollections and IList interface
Interface Segration Principle (SOLID): Clients shouldn’t be forced to depend on methods they don’t use. Create small, focused interfaces, not huge ones.
Violation of Interface Segration Principle:
    public interface IMachine {
        void print();
        void scan();
        void fax();
    }
    public class BasicPrinter implements IMachine {
        public void print() { /* ok */ }
        public void scan() { throw new UnsupportedOperationException(); }
        public void fax() { throw new UnsupportedOperationException(); }
    }
Solution:
    public interface IPrinter {
        void print();
    }

    public interface IScanner {
        void scan();
    }

    public interface IFax {
        void fax();
    }
    public class BasicPrinter implements IPrinter {
        public void print() { /* printing code */ }
    }
We have the same problem in Array as well, Array implements ICollection Interface (numbers.GetType().GetInterfaces()) that has Add() method. But array is fixed size, forcing Array to implement Add method from
ICollection interface is against Interface Segration Principle.
ICollection<int> numbers = new int[] {1,2,3,4,5}; (Not using int[] left side as Add is implemented by Array using Explicit Interface so have to have ICollection<int> on the left side polymorphic way)
numbers.Add(1); // with throw System.NotSupportedException

Interface Segregation Principle: No code should be forced to implement methods it doesn't use
class SomeClass {
    void SomeMethod<T>(ICollection<T> input) where T: new(){
        //some logic
        input.Add(item); //imagine is Array is passed to this method it will fail, because Array forced to implement ICollection interface and Add method, it will fail as Array is fixed size.
    }
}

Benefits of ReadOnly Collection:
    Clear and Simple Code
    Pure fuctions
    Easier MultiThreading
    Keeping objects validOnes
    Avoiding Identity Mutation
    Easier Testing

ReadOnly collections
    var planets = ReadPlanets();  //returned IEnumerable
    var asList = (List<string>)planets;
    asList.Clear(); //clears planets as well as they both point to same Reference. So IEnumerable doesn't make it truly readonly.
Solution make it ReadonlyList
    var planets = ReadPlanets();  // return IReadonlyList
    asList.Clear(); //not allowed

Big O Notation, a fundamental tool to analyze the cost of an algorithm. It tells how the cost of algorithm grows with the size of input.
Below method grow linearly as the input size increases, represented as f(N)=N or O(N) meaning the function that executes is proportional to the input size
    bool Contains<T>(IEnumerable<T> items, T itemToCheck){
        foreach(var item in items){
            if(item.Equals(itemToCheck))
            {
                return true;
            }
        }
    }
Now, below two if checks in place its still same O(N) as above, analog driving from Point A->B you are checking phone twice that doesn't alter the distance you travel
    bool Contains<T>(IEnumerable<T> items, T itemToCheck){
        foreach(var item in items){
            if(item.Equals(itemToCheck))
            {
                return true;
            }
            if(item.Equals(999)) {
                //another operation in the same loop
            }
        }
    }
O(N²) Big O Squared Complexity or Quadratic time complexity: Work grows proportional to the square of the input size. 
Here for size N, two iterations exist causing Quadratic time complexity (O(N))
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            // work
        }
    }
O(1) fastest Algorithm (Big O of 1) complexity also known as constant-time complexity. Their execution time doesn't depend on the size of the input collection. 
Example, retrieving an item in Dictionary has constant time complexity

O(log N) (Big O of log N) Complexity, Binary search uses this.

O(N*M) (Big O of N and M) when two different loops involved
    foreach(var itemA in inputA){
        foreach(var itemB in inputB){
        }
    }

Complexities
    O(1) - constant
    O(log N) - logarithmic
    O(N) - linearly
    O(N*N) quadratic


Binary Search Algorithm: Checks an item exists in a sorted collection and return its index.
    index  0   1   2   3   4   5   6   7   8   9
    value  1   3   4   5   6   11  12  14  16  18
    Example: Lets search for value 12
    leftbound: 0 rightbound: 9 -> leftbound+rightbound/2 -> 4 -> Does value 12 exists at 4 ? No. Value at index 4 is less than 12 (6<12) lets continue the search right half
    leftbound: 5 rightbound: 9 -> leftbound+rightbound/2 -> 7 -> Does index 7 has value 12 ? No. Value at index 7 is larger than 12 (12<14) lets continue the search left half
    leftbound remain as-is: 5 rightbound: 6, leftbound+rightbound/2 -> 5 -> Does index 5 has value 12 ? No. Move to right half, left index: 6 and right index:6 and they have value 12 at index 6
    Suppose left and right index are same and search value not found, then no further search required meaning the value is not contained in the list.
Binary Search uses log₂(N), say you have 100 items number of iterations take to find is 7, reason 2^7 = 128 (our items are )
log₂(n) = log₁₀(n) / log₁₀(2) (calculator)  (log base 2 of n = log base 10 of n divide by log base 10 of 2)
log₂(n) = Y ⇔ 2^Y = n
Say wave 100 items, log2(100) = 6.64, max it takes 7 iterations

Improving performance when using list
    List internal structure is Array, its default size is 4 from thereon capacity doubles for new items (4->8->16->32->64). If we know the size the list is going to accomodate beforehand its better to initialize the capacity to avoid unwanted memory usage List<int> numbers = new List<int>(10);
    Initialize list from another collection. 
        List<number> numbers = new List<int>(anotherList); From Array int[] array = { 1, 2, 3 }; List<int> list = new List<int>(array);
        Initialize using object initializer -> List<Person> persons = new List<Person> {new Person("person1"), new Person("person2")};
    Adding Items
        list.Add(item); //Adds the item to the end of the list
        list.AddRange(new[] {1,2,3,4}) or list.AddRange(new int[] {1,2,3,4}) or list.AddRange([1,2,3,4]);  //Adds multiple items at once.
    RemoveItems
        list.RemoveAt(index); removes an item at the specified index shifts all the elements to the left
        list.Remove(item); removes the specified item if it exists and shifts all the elements to the left
        list.RemoveRange(5, 10); removes 10 items from the index 5

    TrimExcess: Clears unused capacity.
        var list = new List<int>();

        for (int i = 0; i < 10_000; i++)
            list.Add(i);

        for (int i = 0; i < 9_500; i++)
            list.RemoveAt(0);
        list.TrimExcess();

LinkedList:
    A linked list is a linear data structure where each element (called a node) contains:
        a) The data
        b) A reference (pointer) to the next node in the sequence
    Nodes are stored anywhere in memory, and the list is formed by linking them through pointers.
    Head → [Node1] → [Node2] → [Node3] → null

LinkedList vs List
Operation                        LinkedList                                                          List
Get at Index                       O(N)                                                              O(1)
Add Item to front                 .AddFirst->O(1) as only the pointer gets shifted              O(N) numbers.Insert(0, 0); all values from 0 to N gets shifted to the right          
Add Item to end                    O(1)                                                         O(1) becomes O(N) if internal array needs resizing
Delete an Item                   O(1) say A->B->C->D remove C just connect B.Next->D            O(N) removing requires shifting of elements

Dictionary (under the hood)
Its a HashTable with an Array of LinkedList
HashCode of a 2 values can be same (HashCode collision) we have to compare their Key equals as well
Dictionary computes the hashcode of a Key and finds the bucket index and from there it checks a specific key by comparing its key equals to match exact key
For example: Search for Cat finds index 2, bucket has entry 14 (which is the index of Entry Array)
Buckets array (index → entry index):
Index:   0     1     2     3
Value:  [ 3 ] [ -1 ] [ 14 ] [ -1 ]

Entries array:
Index | Key | Next
-------------------
3     | K3  | 10
10    | K10 | -1
14    | K14 | -1

An Entry looks like this
    struct Entry {
        public int hashCode;
        public TKey key;
        public TValue value;
        public int next;  // index of next entry in the same bucket
    }
Colliding keys create a chain of entries
    If multiple keys produce the same bucket index, the dictionary chains them like this:
Bucket 3
   ↓
Entry 5  →  Entry 12  →  Entry 27  →  -1

HashSet:
    List<string> names = new List<string> { "john", "andrew", "philip" };
    Finding if name contained in names => names.Contains("henry");  List Contains complexity is O(N) as it enumerates foreach each item.
HashSet is faster as it hashes the values and searches complexity is O(1), its faster as internally uses hashcode and retrieves faster
    HashSet<string> names = new HashSet<string> { "apple", "banana", "orange" };
    names.Contains("apple");
Note: HashSet and Dictionary items stored are not stored in the order it received as List.
For Sorted we have SortedSet and SortedDictionary
Combining two HashSet and resulting in a new Hashset without modifying input Hashset
        public static HashSet<T> CreateUnion<T>(
            HashSet<T> set1, HashSet<T> set2)
        {
           var combinedHashSet = new HashSet<T>(set1);
           combinedHashSet.UnionWith(set2);
           return combinedHashSet;
        }    

Queue: Linear data structure elements added to end of the Queue, while removing removed from front of the Queue(FIFO)
    Queue<string> queue = new Queue<string>();
    queue.Enqueue("apple");
    queue.Enqueue("banana");
    Console.WriteLine(queue.Dequeue()); //apple
    Console.WriteLine(queue.Dequeue()); //banana
    Peak Method: queue.Peek() allows to see the value without removing the item from the queue.

PriorityQueue: Queue that takes priority for the item when entered
    PriorityQueue<string, int> priorityQueue = new PriorityQueue<string, int>();
    priorityQueue.Enqueue("apple", 2);
    priorityQueue.Enqueue("banana", 5);
    priorityQueue.Enqueue("orange", 4);
    priorityQueue.Enqueue("grape", 1);
    priorityQueue.Enqueue("mango", 3);

    Console.WriteLine(priorityQueue.Dequeue()); //grape
    Console.WriteLine(priorityQueue.Dequeue()); //apple
    Console.WriteLine(priorityQueue.Dequeue()); //mango
    Console.WriteLine(priorityQueue.Dequeue()); //orange
    Console.WriteLine(priorityQueue.Dequeue()); //banana

Stack:
    Stack is a linear data structure, where elements added and removed to/from the top, that stores elements in a LIFO (Last-In, First-Out) order.
    Stack<string> stack = new Stack<string>();
    stack.Push("apple");
    stack.Push("banana");
    stack.Push("orange");
    stack.Push("grape");
    stack.Push("mango");
    Console.WriteLine(stack.Pop()); //mango
    Console.WriteLine(stack.Pop()); //grape
    Console.WriteLine(stack.Pop()); //orange
    Console.WriteLine(stack.Pop()); //banana
    Console.WriteLine(stack.Pop()); //apple

params: The params modifier allows a method to accept a variable number of arguments as a single parameter.
PrintNumbers(1, 2, 3, 4);
 void PrintNumbers(params int[] numbers)
{
    foreach (var n in numbers)
        Console.WriteLine(n);
}   
Only one parameter in a method can use the params modifier, and it must be the last parameter in the method’s parameter list.
    void Log(string message, params string[] tags) { }

Stack Extension method: checks if any items in given input exists inside Stack (note: we are not pop-ing the item)
 public static bool DoesContainAny(this Stack<string> stack, params string[] input) =>
     stack.ToArray().Intersect(input).Any();

Yield
    Yield returns an Iterator consider it as a state machine. Iterator is a container of data and doesn't return immediately. As you enumerate thats when data is returned one by one.
    Lets say you're reading 10GB of file, you may need only first few lines yield can help here. 
    Refer: #Yield

    YieldSample yieldSample = new YieldSample();
    IEnumerable<int> numbers = yieldSample.GetNumbers();
    foreach (int number in numbers)
    {
        Console.WriteLine($"Consuming {number}");
    }
    public class YieldSample {
        public IEnumerable<int> GetNumbers() {
            for (int i = 0; i < 4; i++)
            {
                Console.WriteLine($"Yielding {i}");
                yield return i;
            }
        }
    }
output:
    Yielding 0
    Consuming 0
    Yielding 1
    Consuming 1
    Yielding 2
    Consuming 2
    Yielding 3
    Consuming 3

Yield Break: 
    Stops the Iterator from further yield    

IEnumerable interface using Iterators
When implementing IEnumerable interface instead of Custom Enumerator like WordsEnumerator, we can use yield to return an iterator.
#IEnumerableInterface    

Note: int i=100000; can also be written as 100_000; C# allows digit separators using the underscore _ to make large numbers easier to read.

List can be initialized with capacity, var list = new List<string>(1000000);

Innerclass
public class ClassA { public class ClassB { private class ClassC {} }  }
Only classes directly under namespace cannot be private 