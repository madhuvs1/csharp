Ultimate Csharp Masterclass Krystyna Ślusarczyk
Section1:
https://docs.google.com/document/d/143KZel4EeLloysAVyhR0rmdirHnsTDPleRWrxo0jJEs/edit?usp=sharing
Section2:
https://docs.google.com/document/d/1chi9W7E0tHe1gN2undJdpyvO3BVUDmzfYjoKEnPOQew/edit?usp=sharing
Repository:
https://github.com/KrystynaSlusarczykLearning/UltimateCSharpMasterclass

Section2:
Obj folder stores intermediate build artifacts and incremental compilation data for all changed files.
Asp.net To speed up builds during debug or development, modify the project file (.csproj) to disable nonessential build steps such as Razor precompilation and analyzers.

Variables:
Shortcut: Ctrl+D duplicates the line
Multiline Comment: ctrl+shift+/   (ctrl+k+c to comment and ctrl+k+u to uncomment)
Format: ctrl+k, ctrl+d

Implicitly typed variable: var 

REPL (Read Eval Print Loop similar to jshell)
dotnet tool install -g csharprepl
csharprepl
    Gets into interactive mode

C# is a statically typed programming language
int x= 10; x="hello"; not allowed

Convert.ToInt32 vs int.parse
    Convert.ToInt32 accepts null, string, double values if its not overflowing
    int.parse excepts the param to be string
    However int.TryPase is efficient handles all cases

switch case
switch(str) {
    case "fruit":
    case "Fruit":
     Console.WriteLine("Its a fruit");
     break;
    case "Vegetable":
     Console.WriteLine("Its a Vegetable");
     break;
    default:
      Console.WriteLine("Its not a fruit or Vegetable");
     break;
}
Switch Expression
var result =  str switch {
    "fruit" or "Fruit" => "Its a fruit",
    "Vegetable" => "Its a Vegetable",
    _ => "Its not a fruit or Vegetable"
};
Console.WriteLine(result);


MultiDimensional Array
char[,] = new char[2,3];  (Two rows 3 columns)
char[,] char2DArray = new char[,] { {'A','B','C'}, {'D','E','F'} };
Get rows => char2DArray.GetLength(0);  Get columns => char2DArray.GetLength(1);

VariableNames:
@string allowed
1name NOT allowed 
int NOT allowed
first&name NOT allowed

Object Oriented programming (OOP) - Based on concept of objects that contain data and methods.
Objects hold data and behaviors (methods), while a class serves as the blueprint from which those objects are created.
OOP relies on fundamental concepts Encapsulation, Polymorphism, Abstraction and Inheritance 

AccessModifier: public, private, protected, internal
protected: 
    public class Animal { protected string MakeNoise() => "Roar"; }
    public class Tiger : Animal { }
    new Tiger().MakeNoise(); compiler error method MakeNoise() can be accessed only inside Animal or Tiger object not outside.
DateHiding: Using AccessModifier like private and hiding its accessibility outside class

Init:  public int Count {get; init;}
    Property setter modifier, allows the value to be set only in constructor or object initialization

TopLevel statements:
Starting with .NET 6, the Program.cs file uses top-level statements, which hide the explicit Program class and Main() method.
You can restore or override this behavior by adjusting the project settings.

MethodNames: Start with Verb and End with Noun

Encapsulation vs Hiding
Encapsulation = wrapping data + behavior
Data hiding = controlling access to that data (using access modifiers private)

MethodOverloading
    Methods that have the same name but differ in parameter types, number of parameters, or the order of parameters.
Constructor MethodOverloading
    Appointment(string name, string days){}
    Appointment(name):this(name, 7) {}  // here a constructor is calling another constructor

Expression vs statements
Statements doesn't return a value; eg; Console.WriteLine("hello world")
Expression that returns a value public int Add(int a, int b){return a+b;}
Expression Bodied Members: Used when a method, property, or other member consists of a single expression instead of multiple statements.
    public int Add(int a, int b) => a + b;

Optional parameters:
    Methods can have optional parameters but has to be compile time constant 
    public void MakeAppointment(string name, int day=7) - allowed
    public void MakeAppointment(string name, int day=GetDays()) - NOT allowed

nameof
    returns the variablename as string 
    class Person {public string Name;}  -> nameof(Person.Name)

Const (Constant) and Readonly
Const: Used on variable that has compile time constant (PascalCase) 
    example: public const double Pi = 3.14159;
readonly: Variables that can be initialized on declaration or in construtor CANNOT be used in constructors
   example: public readonly int InstanceId = 1; or public class Instance { public Instance(int instanceId) { InstanceId = instanceId;  } }    
Casing: const → PascalCase  |  readonly → camelCase (private) or PascalCase (public) 

Static:
    Used on methods that are stateless
    Static class can have only static Members, it can have parameterless constructor which executes once and is private by default
    Instance class can have both Static and Instance members

String Join Split
    String.Join(",", strArray) => results in a string
    str.Split(",")  => results in an array, splits string with the delimiter


Single Responsibility Principle: A class that has only one reason to change. 

DRY principle (Dont Repeat Yourself) states that we shouldn't have multiple places in the code where the same business decisions are defined.

GlobalUsings
Namespaces defined in GlobalUsings.cs available for all classes (optionally you can define them in the project file)
                                <ItemGroup><Using Include="System" /><Using Include="System.Collections.Generic" /></ItemGroup>
Globalalias
    global using IO = System.IO;

Enum
    An enum (short for enumeration) is a special value type that lets you define a set of named constants — typically used to represent a fixed group of related values.
enum ErrorCode { None = 0, NotFound = 404, ServerError = 500 }

Inheritance (is-a relationship)
    public class Car {} public class Honda:Car {}  //Honda is a Car

Overriding
Derived class can override Base class methods provided the base class method is declared virtual
    class Animal
    {
        public virtual void Speak()  {        Console.WriteLine("Animal sound");     }
    }
    class Dog : Animal
    {
        public override void Speak() { Console.WriteLine("Bark");        }
    }    

Animal a = new Dog();
a.Speak(); //output: Bark

Shadowing or Hiding
Derived class hides Base class method by using "new" each has its own implementation 
    class Animal
    {
        public void Speak()  {        Console.WriteLine("Animal sound");     }
    }
    class Dog : Animal
    {
        public new void Speak() { Console.WriteLine("Bark");        }
    }
Animal animal = new Dog();
animal.speak(); //output: Animal sound        

Diamond Problem in Inheritance:
When a class inherits from two or more classes that share a common ancestor, creates a Diamond shape hierarchy. Ambiguity arises if a method is derived in the intermediate classes, end derived class doesn't know which one to use.

System.Object is the baseclass for all classes 

Constructor:
    Derived class instantiation always calls Base class constructor first. 
    Animal{Animal(int legs){} }  Cat:Animal { Cat(int legs) : base(legs) {} }

Explicit Conversion:
    decimal (0.01m) and double are floating point types. decimal has more precision (used in banks) double has less precision (used in scientific calculation)
    double is faster as its a native type to CPU, decimal is a software emulated type.
    implicit conversion int x = 2; decimal d = x; 
    decimal d = 0.01m; int x = d; (not possible as there is a loss), so we do => int x = (int)d;

    enum season {spring, summer, autumn, winter} int x= 11;
    season s = (season)x;  Here explicit conversion should fail but doesn't. Should be cautious when using explicit
    For int types, (Enum.IsDefined(typeof(season), x)) For string types, Enum.TryParse()
    
    UpCasting DownCasting
    Animal:Cat Animal:Dog 
        Animal a = new Dog(); this is upcasting derived class assigned to a base class
    Animal a = new Dog();
    Dog = a; This is downcasting, but not safe what if Animal holds Cat instead of Dog

    "Is" Operator
        Animal a = new Dog(); a is Dog ? returns true;
    "Is" Assignment
        List<Dog> dogs;
        if(a is Dog x){ dogs.add(x);}  //Here a is Dog does type check followed by variable makes assigment to variable x; 
    If you wonder why can't I just add dogs.add(a); instead of dogs.add(x) first one does casting to Dog, whereas second doesn't do casting
    Here does safe type check if(a is Dog x) another alternative way
        newList.Add((TTarget)Convert.ChangeType(item, typeof(TTarget))); //not type safe

    "As" Operator
    Animal a = new Dog();
    Cat c = (Cat)animal - Standard cast Expression it will throw Invalid CastException due to incompatible types
    Cat c = animal as Cat - as cast Expression, returns null instead of exception

Abstract class
    Class that cannot be instantiated but can be derived from it. Its not must for an abstract class to have abstract methods.

Sealed class:
   sealed class Vehicle, disallows deriving from this class.

Sealed method:
    sealed method disallows futher overridding 
    class base {virtual void show(){}}  class derived { sealed override void show() {} }  class subderived { //cannot overrider show further here}
    Static classes are implicitly sealed

Extension method:
    Add a method to an existing Type without modifying the actual type
    example: public static class StringExtension { public static string NewSting(this string s) { return s; }}
    Index in list -> List<int> intList = new List<int> {1,2,3,4,5,6}; intList.Where((value,index) => {});

Interface:
 Its a contract, defines what a class must do, but not how it does it.
 From C#8 allows default method implementation
 interface ILogger { void Log(string message); void LogError(string message) { Log(message);  }  } This way in a setup where classes that already inheriting from the interface, adding default implementation to the interface won't break other classes.
 interface inheritance is idempotent, meaning if the same interface appears more than once in the inheritance chain, compiler treats it as one.
 A class can inherit from multiple interfaces, but only one class concrete/abstract class

Target typed new expression (available from C# 9)
Class1 c1 = new (); (equivalent to Class1 c1 = new Class1())

Dependency Inversion Principle: 
    High level modules should not depend on low level modules, both should depend on abstractions. OrderService -> IQuoteService  <- QuoteService

typeof(Compile time) vs GetType (RunTime on an instance)
typeof("hello") -> System.String
person.GetType()


UML:
Aggregation
	Aggregation example: (Here dependency Professor is injected and mapped to a class level field (or property)
	class Department{
		private Professor _professor;
		Department(Professor professor){
			_professor = professor;
		}
	}  
	Definition: Aggregation a week whole-part("has-a") relationship, UML: ◇—— hollow Diamond Arrow pointed at Depender. Aggregation: Department ◇—— Professor. Why weak when Department disposes still Professor exists

Composition
	Composition example: (Dependency Professor is created within Depender)
	Class Department {
		private Professor _professor;
		Department(){
			_professor = new Professor();
			}
		}
	Definition: Composition, a strong whole-part ("owns-a") relationship, Solid Diamond Arrow pointed at Depender Composition: Department ◆—— Professor. Why strong when Department is disposed Professor is disposed as well
Association
	Assocation example: (Here dependency Professor is used, but not mapped to any field/property as class level
	class Department {
		public void Teach(Professor professor){}
	}
	Definition: Association ("uses-a") Professer object, Solid line Arrow Pointed at Dependency. Department ———> Professor.
Generalization (Inheritance)
    Generialization example, Maths "is a" Department
    class Maths: Department {}
    Definition: Generialization, there exists "is a" relationship between child(Maths) and parent(Department) UML: Maths ─────▷ Department (triange arrow head)


Exception and Error Handling
3 Types: Compile time errors , RunTime errors and Logical errors
Exception base class is System.Exception, all other excpetion types derived from System.Exception
Known exception types: ArgumentException: {ArgumentNullException(eg: input null), ArgumentOutOfRangeException(eg weekday input: 8)}, InvalidOperationException(input collection is empty)
StackOverflowException:
    RecursiveMethods:  if there is method calling itself this could be result in StackOverflowException
throw ex vs throw (throw ex is bad practise)
a)
        Method1(){
            try{
                Method2();
            }
            catch(NullReferenceException ex) {
                //ex.stacktrace shows Method2 when throw ex was performed in Method1 as it resets the stack trace;
                //ex.stacktrace shows Method1<-Method2 when throw was performed 
            }
        }
        Method2(){
            try{
                throw NullReferenceException("object is null");
            }
            catch(NullReferenceException ex){
                throw;
                //throw ex; //bad practise as it resets the stack trace
            }
        }
b) Pass ex (original exception) while throwing -> throw new ArgumentNullException("The collection is null", ex);
 Method1(){
            try{
                Method2();
            }
            catch(NullReferenceException ex) {
              //Here ex.Message shows "The collection is null"
              //ex.StackTrace points to the place where its thrown here its -> throw new ArgumentNullException("The collection is null", ex);
              //ex.InnerException shows "Object Reference not set.... because while doing throw new, ex is passed as second param.
              //ex.InnerException.StackTrace points to the root (origin) of exception -> throw NullReferenceException("object is null");
              
            }
        }
        Method2(){
            try{
                throw NullReferenceException("object is null");
            }
            catch(NullReferenceException ex){
                throw new ArgumentNullException("The collection is null", ex);
            }
        }
Exception filter: catch when (ex.Message.StartsWith("400")) {}
 Catch block condition (when) allows conditionally catching exception

Shortcut:
ctrl+Shift+Space: shows available overloads for a method/constructor...
    File.ReadAllLines() (place the cursor inside the parenthesis and press ctrl+shift+space)

CustomException:
    Derives from Exception class, 
    [Serializable]  //optional
    public class CustomException : Exception
    {
        public string Data {get;}
        // 1️⃣ Default (parameterless)
        public CustomException(): base() { }
        // 2️⃣ Message-only
        public CustomException(string message) : base(message) { }
        // 3️⃣ Message + inner exception 
        public CustomException(string message, Exception innerException) : base(message, innerException) {  }
        // 4️⃣ Message + inner exception + Data 
        public CustomException(string message, Data data, Exception innerException) : base(message, innerException) {this.Data = data; }
        // 5️⃣ Serialization (for remoting or custom serialization) //optional
        protected CustomException(System.Runtime.Serialization.SerializationInfo info,
                                System.Runtime.Serialization.StreamingContext context) : base(info, context) { }
    }
If your exception may be serialized or re-thrown across application domains or process boundaries,
then you must include the serialization constructor (the 5th one). Its legacy way not needed

If your code uses reflection, DI frameworks, or rethrow logic that assumes exceptions can be created dynamically, a parameterless constructor helps those frameworks instantiate your exception safely.    

Generic types:
    IEnumerable<T>
        ↑
    ICollection<T> : IEnumerable<T>
        ↑
    IList<T> : ICollection<T>, IEnumerable<T>
        ↑
    List<T> : IList<T>, ICollection<T>, IEnumerable<T>
DataStuctures: Are types meant for storing and organizing data so that it can be accessed and modified efficiently.    
Examples of DataStructures: 
Linear: Arrays, List, LinkedList, Stacks, Queues
Non-Linear: Tree, BinaryTree, Graph
Hash-Based structures: Dictionary, HashSet
Specialized Structures: PriorityQueue, Tuple/Record

List uses Array under the hood for datastorage. When items added to the list, Array is resized(doubled default is 4, next time it will become 8). 
And when items are removed, size is not shrinked unless explicitly called list.TrimExcess()
    Sample: Refer CodeSnippets.txt #CustomGenerics

Simple generic type: refer CodeSnippets #SimpleGenericType

Tuple
    A lightweight data structure to group multiple data elements into a single object without the need to create custom class or struct
Implicit named Tuple: example: var person = ("John",20)    // person.Item1 contains John
Named Tuple: (string name, int age) person = ("John", 20) // person.name contains John

Generic Method:
Class can be non-generic but its methods can be generic
Refer: CodeSnippets #GenericMethod   

Type constraint:
    i) Limits types to be used for Generic type that parameterless constructor
    IEnumerable<T> RandomCollectionGenerator<T>(int maxLength) where T: new() { // where T:new() ensures T types should be classes only that have parameterless constructor 
        var randomLength = Random.Next(maxLength+1);
        var result = new List<T>(randomLength);
        for(int i=0;i<randomLength;i++){
            result.Add(new T());
        }   
    }
    ii) Limit specific types for the Generic Type 
    public class Person{public int Year {get;set;}} public class Employee: Person {}
    public IEnumerable<T> GetValid<T>(IEnumerable<T> input) where T: Person {
        List<T> validOnes = new List<T>();
        foreach(var item in input){
            if(item.Year > 1900 && item.Year < DateTime.Now.Year)
                validOnes.Add(item);
        }
        return validOnes;
    }

List creation with size
    If we know the size, initialise list with size, otherwise list has to resize internal array (4,8,16,32...)
    new List<int>(size); 

Time Consumption (performance measurement)
    StopWatch stopWatch = StopWatch.StartNew();
    MethodCall();
    stopWatch.Stop();
    stopWatch.ElapsedMilliseconds // gives the time consumed by method

Invariant: You cannot substitute one generic type argument for another, even if there is inheritance relationship between those types Refer: #Invariant

Covariance is required when a generic interface (or delegate) should allow a derived implementation that uses a derived type argument to be assigned to a base interface reference that uses the base type argument.     
Refer: #Covariance

Contravariance is the opposite of Covariance. Refer: #Contravariance

IComparable interface lets compare two objects. In this comparison, we compare two objects based on a property
Refer: #IComparable

Type Constraint - numeric types.
Use the INumber interface lets perform math operation (square) on generic types
 public static T Square<T>(T t) where T : INumber<T> => t * t;

Func Action Delegates
    Func is a generic delegate type that represents a method which returns a value;
    Action is a built-in delegate type in C# that represents a method that does not return a value
    Note: Func<int,bool>, you can use Predicate here -> Predicate<int> (it returns bool)

Lambda Expression: Inline anonymous method
    Anonymous methods: (parameters) => expression
Expression vs Statement:
    Expression evaluates to a value x+y 
    Statement performs an action: Console.WriteLine("HelloWorld"), int x=5, x++;

Delegate: Type whose instances hold a reference to a method(methods), declaration looks similar to method declaration.
delegate string ProcessString(string input);
Multicast delegate references multiple methods, via delegate instances in its invocation list.
refer #delegates

Dictionary: (DataStructure)  Generic Collection of KeyValue pairs (HashTable -Legacy non generic)
    Allows quick lookup a value based on its key. Keys must be unique.
How Dictionary achieves quick lookup ?
    Dictionary internally has buckets of memory, it will store the key in one of the bucket. When you store a key -> gets the hashcode of the key ->
    say 12345 ->  Assume Dictionary has 5 buckets -> Now bucketIndex = HashCode % No. of buckets -> 1234/5 = 4. It stores the key in bucket 4. During retrieval using the 
    hashcodeOfkey % NoOfBuckets finds the bucket to find the value.
 ContainsKey checks whethere the keys exists in the Dictionary

 Strategy Design Pattern- Behavioral pattern(Gof-GangOfFour)
    The behavior of a class can be decided at runtime when the abstraction it depends on is associated (or injected) with a concrete derived implementation.
    Its an implementation of Open/Closed Principle in SOLID design principle
    Refer: #StrategyDesignPattern

Decorator pattern - Behavioral pattern
    Adds new behavior or features to an existing object without changing its code. Lets say initially you had only EmailNotifier for INotifier, later when you want to extend for SMS
    and Slack as below, here we decorate/wrap additional objects to achieve it. Idea is each hold reference of predecessor initialized in the constructor. When the send method called 
    it calls base.Send() first. Refer #Decorator Pattern
     services.AddTransient<INotifier>(sp =>
        {
            INotifier n = new EmailNotifier();
            n = new SMSNotifier(n);
            n = new SlackNotifier(n);
            return n;
        });
Class vs Struct
Class is a reference type.
Struct is a value type. It can be made immutable public readonly struct Coordinates { int x; int y; }
Struct when copied it, it copies whole no references. (Struct s1=s2;) Except if you modify a reference type of Struct it gets affected both places. However if the reference type is reinitialized 
it will affect only on the struct where its done.
Refer: #ClassVsStruct