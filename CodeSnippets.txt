#CustomGenerics
        public class ListOfInt {

            private int[] _intArray = new int[IntArraySize];
            public static int IntArraySize { get; set; } = 4;
            private int _freeIndex = 0;

            public void Add(int x) {
                if (_freeIndex > IntArraySize - 1)
                {
                    var tempArray = new int[IntArraySize * 2];
                    for (int i = 0; i < IntArraySize; i++)
                    {
                        tempArray[i] = _intArray[i];
                    }
                    IntArraySize = IntArraySize * 2;
                    _intArray = tempArray;
                }
                _intArray[_freeIndex++] = x;
            }
            public void RemoveAt(int x) {
                if(x >= _freeIndex) throw new ArgumentException(nameof(x));
                for (int i = x; i < _freeIndex-1; i++) {
                    _intArray[i] = _intArray[i+1] ;
                }
                _freeIndex--;
            }
            public int GetAtIndex(int index) {
                return _intArray[index];
            }
        }
usage: 
    ListOfInt listOfInt = new ListOfInt();
    listOfInt.Add(1);
    listOfInt.Add(2);
    var intValueAtIndex5 = listOfInt.GetAtIndex(5);
    listOfInt.RemoveAt(4);        

#SimpleGenericType
    public class Pair<T> {
        public T First{get;private set;}
        public T Second{get; private set;}
        public Pair(T first, T second){
            First = first;
            Second = second;
        }
        public void ResetFirst(){
            First = default(T);
        }
        
        public void ResetSecond(){
            Second = default(T);
        }
    }
usage: var pair = new Pair<string, string>("hello", "world");            

#GenericMethod
    public class NonGeneric
    {
        public void Add<T>(T obj)
        {
            Console.WriteLine(typeof(T));
        }
    }
    public static class ListExtension
    {
        public static List<TTarget> ConvertTo<TSource, TTarget>(this List<TSource> input) where TSource : class  where TTarget : class
        {
            var newList = new List<TTarget>();
            foreach (var item in input)
            {
                if(item is TTarget target)
                    newList.Add(target);
            }
            return newList;
        }
    }

#Tuple
    public static class TupleSwapExercise
    {
        //new way
        public static (T2, T1) SwapTupleItems1<T1, T2>((T1 param1, T2 param2) item)
        {
            return (item.param2, item.param1);
        }
        public static (T2, T1) SwapTupleItems2<T1, T2>((T1, T2) item) { 
            return (item.Item2, item.Item1);
        }
        //legacy way
        public static Tuple<T2, T1> SwapTupleItemsOld<T1, T2>(Tuple<T1, T2> tuple) {
            return new Tuple<T2,T1>(tuple.Item2, tuple.Item1);
        }
    }

#Invariant
class Person { }
class Employee : Person { }
List<Employee> employees = new List<Employee>();
List<Person> persons = employees; // ❌ Error — List<T> is invariant


#Covariance
Detailed example:
Scenario, you need to get list of Animals from shelter and print them. As you see a generic provider (IAnimalProvider) has ability to get all types of animals. For an interface to 
achieve this that can take parent type(animal) and allow its derived types you have to define a Generic Interface using out keyword (generic modifier) AND method should not take 
generic parameter T as input, rather it should only return T (producer not consumer)
public static class AnimalChecker
{
    public static void PrintAnimals(IAnimalProvider<Animal> provider)
    {
        while (true)
        {
            var animal = provider.GetNext();
            if (animal == null) return;
            Console.WriteLine(animal.Name);
        }
    }
}
Lets create the Interface with out generic modifier
public interface IAnimalProvider<out T> {
	public T GetNext(); //Note here T is returned not consumed that's a rule for Covariance
}

Now define templates for Animal and its derived ones Dog and Cat
	public class Animal
	{
		public string Name { get; set; }
		public virtual void Sound() { Console.WriteLine("Animal Sound"); }
	}
	public class Dog : Animal
	{
		public override void Sound() { Console.WriteLine("Bow Bow"); }
	}
	public class Cat : Animal
	{
		public override void Sound() { Console.WriteLine("Meow Meow"); }
	}

Now to satisfy PrintAnimals lets make derive from Covariant Generic interface
	public class DogProvider : IAnimalProvider<Dog>
	{
		private readonly Queue<Dog> _dogs = new Queue<Dog>();
		public DogProvider()
		{
			_dogs.Enqueue(new Dog { Name = "Rex" });

			_dogs.Enqueue(new Dog { Name = "Buddy" });

		}
		public Dog GetNext()
		{
			return _dogs.Count > 0 ? _dogs.Dequeue() : null;
		}
	}
One more for Cat lets make derive from Covariant Generic interface
	public class CatProvider : IAnimalProvider<Cat>
	{
		private readonly Queue<Cat> _cats = new Queue<Cat>();
		public CatProvider()
		{
			_cats.Enqueue(new Cat { Name = "Lexie" });

			_cats.Enqueue(new Cat { Name = "Scarlet" });

		}

		public Cat GetNext()
		{
			return _cats.Count > 0 ? _cats.Dequeue() : null;
		}
	}

With this setup, different providers holding subtypes(dog, cat) can be substitued for Animal generic parameter
	AnimalChecker.PrintAnimals(new DogProvider());
	AnimalChecker.PrintAnimals(new CatProvider());
output: 	
	Rex
	Buddy
	Lexie
	Scarlet

--------
    public class Person {}
    public class Employee: Person {}
    public interface IDataProvider<out T> { T GetData(); }
    public class EmployeeDataProvider: IDataProvider<Employee> {
        public Employee GetData(){}
    }
    IDataProvider<Person> person = new EmployeeDataProvider();

#Contravariance
    public class Person{}
    public class Employee{}
    public interface  IDataSaver<in T>{ void Save(T data) }
    public class PersonDataSaver: IDataSaver<Person>{
        public void Save(Person data);
    }
    IDataSaver<Employee> dataSaver = new PersonDataSaver();
    dataSaver.Save(new Employee());

#IComparable
    public class Person: IComparable<Person> { 
        public int YearOfBirth { get; set; }
        public string Name { get; set; }
        public int CompareTo(Person other) {
            if (this.YearOfBirth < other.YearOfBirth) return -1; //(1940 < 1950)  meaning this.YearOfBirth(1940) stays in front and other.YearOfBirth(1950) moved to last
            else if(this.YearOfBirth > other.YearOfBirth) return 1; //reverse of above
            return 0; //no change to the list
        }
    }
    Another usecase to sort names first by lastname and then firstname
    public class SortedList<T> where T: IComparable<T>
    {
        public IEnumerable<T> Items { get; }

        public SortedList(IEnumerable<T> items)
        {
            var asList = items.ToList();
            asList.Sort();
            Items = asList;
        }
    }

    public class FullName: IComparable<FullName>
    {
        public string FirstName { get; init; }
        public string LastName { get; init; }

        public override string ToString() => $"{FirstName} {LastName}";

        public int CompareTo(FullName other)
        {
            if (other.LastName == LastName) {
                return FirstName.CompareTo(other.FirstName);
            }
            return LastName.CompareTo(other.LastName);
        }
    }

#Func
//Inline func example
    Func<string, int> stringLength = x => x.Length;
    Console.WriteLine(stringLength("HelloWorld"));
    Func<int, int, int> sumOfTwoNumbers = (x, y) => x + y;
    Console.WriteLine(sumOfTwoNumbers(1,1));
//Assign func to an existing method
    Func<int, int, int> Func1 = Add;
    public int Add(int a, int b) => a+b;
//Func as parameter to class you pass implementation to method param
    FuncClass funcClass = new FuncClass();
    Console.WriteLine(funcClass.FuncMethod(x => x.Length));
        public class FuncClass {
        public int FuncMethod(Func<string, int> func) => func("HelloWorld");
    }
//Func as class level fields    
    public class Exercise
    {
        public Func<string, int> GetLength = (x) => x.Length;
        public Func<int> GetRandomNumberBetween1And10 = () => new Random().Next(2, 10);
    }
#delegates
    public string TrimTo5Letters(string input){return input.Substring(0,5);}
    public string ToUpper(string input) {return input.ToUpper();}
    delegate string StringProcessor(string input);
    StringProcessor stringProcessor1 = TrimTo5Letters;
    StringProcessor stringProcessor2 = ToUpper;
    Console.WriteLine(stringProcessor1("HelloWorld"));
    Console.WriteLine(stringProcessor2("HelloWorld"));
Multicast delegate:
    public class DelegateBench {
        public void TrimTo5Letters(string input) { Console.WriteLine(input.Substring(0, 5)); }
        public void ToUpper(string input) { Console.WriteLine(input.ToUpper()); }
        public delegate void StringProcessor(string input);

        public void Test()
        {
            StringProcessor stringProcessor1 = TrimTo5Letters;
            StringProcessor stringProcessor2 = ToUpper;
            StringProcessor stringProcessor = stringProcessor1 + stringProcessor2;
            StringProcessor stringProcessor3 = x => Console.WriteLine(x.ToLower());
            stringProcessor += stringProcessor3;
            stringProcessor("HelloWorld");
        }
    }
    DelegateBench delegateBench = new DelegateBench();
    delegateBench.Test();

#event
    public class TravelVideos
    {
        // Event to notify when a new video is uploaded
        public event Action<string> VideoUploaded;

        // Called when a new video is added
        public void UploadVideo(string videoTitle)
        {
            Console.WriteLine($"[Publisher] Uploading new travel video: {videoTitle}");

            // Notify all subscribers safely
            VideoUploaded?.Invoke(videoTitle);
        }
    }

    public class EmailService
    {
        private string _subscriberEmail;
        public EmailService(string subscriberEmail)
        {
            _subscriberEmail = subscriberEmail;
        }
        public void SendEmailNotification(string videoTitle) =>
           Console.WriteLine($"[Email] Sent to {_subscriberEmail}: New video → {videoTitle}");
    }


startup.cs
    var travelVideos = new TravelVideos();

    // 3 subscribers, each with different email addresses
    var subscriber1 = new EmailService("alice@example.com");
    var subscriber2 = new EmailService("bob@example.com");
    var subscriber3 = new EmailService("charlie@example.com");

    // All three subscribe to the event
    travelVideos.VideoUploaded += subscriber1.SendEmailNotification;
    travelVideos.VideoUploaded += subscriber2.SendEmailNotification;
    travelVideos.VideoUploaded += subscriber3.SendEmailNotification;

Event Trigger when the video upload event occurs
    travelVideos.UploadVideo("Switzerland Skiing");

Output: 
    [Publisher] New travel video uploaded: Switzerland Skiing
    [Email] Sent to alice@example.com: New video → Switzerland Skiing
    [Email] Sent to bob@example.com: New video → Switzerland Skiing
    [Email] Sent to charlie@example.com: New video → Switzerland Skiing





#Dictionary
    Dicationary<string,string> countriesAndCurrency = new Dictionary<string,string>();
    countriesAndCurrency["USA]="USD"
    Initialize Dictionary with multiple key values
    Dicationary<string,string> countriesAndCurrency = new Dictionary<string,string> {
        ["USA"] = "USD",
        ["India"] = "INR"
        ["Spain"] = "EUR"
    }
   
    public static class Exercise
    {
        public static Dictionary<PetType, double> FindMaxWeights(List<Pet> pets)
        {
            //using linq groupby return pets.GroupBy(x => x.PetType).ToDictionary(g => g.Key, g => g.Max(p=> p.Weight));
            Dictionary<PetType, double> petsWithMaxWeight = new Dictionary<PetType, double>();
            foreach (Pet pet in pets) {
               var petsByType = pets.FindAll(x => x.PetType == pet.PetType);
                petsWithMaxWeight[pet.PetType] = petsByType.Max<Pet>(x => x.Weight);  
            }
            return petsWithMaxWeight;
        }
    }

#StrategyDesignPattern
    Example1: Strategy pattern using interface
    public interface IPaymentStrategy { void pay(); }
    public PayPal: IPaymentStrategy{ public void Pay() {Console.WriteLine("Processing PayPal payment");} }
    public CreditCard: IPaymentStrategy{ public void Pay() {Console.WriteLine("Processing CreditCard payment");} }
    public class OrderService {
        public void ProcessPayment(IPaymentStrategy paymentStrategy){
            paymentStrategy.Pay();
        }
    }
    Example2: Strategy pattern using Function Delegates
    public class StrategySelector
    {
        public static Predicate<int> SelectStrategy(string userInput)
        {
            return userInput switch
            {
                "even" => x => x % 2 == 0,
                "odd" => x => x % 2 == 1,
                "positive" => x => x > 0,
                "negative" => x => x < 0,
                _ => throw new InvalidOperationException("Invalid user choice")
            };
        }
    }

    public class NumbersFilter
    {
        public static List<int> Filter(Predicate<int> func, List<int> numbers)
        {
            var filteredList = new List<int>();
            foreach (int i in numbers)
            {
                if (func(i)) filteredList.Add(i);
            }
            return filteredList;
        }
    }
    var userInput = Console.ReadLine();
    var strategy = StrategySelector.SelectStrategy(userInput);
    var numbers = new List<int> { -3, -2, -1, 0, 1, 2, 3, 4, 5, 6 };
    var filteredNumbers = NumbersFilter.Filter(strategy, numbers);
    Console.WriteLine(string.Join(",", filteredNumbers));

#Decorator Pattern
    services.AddTransient<INotifier>(sp =>
    {
        INotifier n = new EmailNotifier();
        n = new SMSNotifier(n);
        n = new SlackNotifier(n);
        return n;
    });
    public interface INotifier
    {
        void Send(string message);
    }
    public class EmailNotifier : INotifier
    {
        public void Send(string message)
        {
            Console.WriteLine($"Email {message}");
        }
    }

    public class SmsNotifier : INotifier
    {
        private readonly INotifier _notifier;
        public SmsNotifier(INotifier notifier) { _notifier = notifier; }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Sms {message}");
        }
    }

    public class SlackNotifier : INotifier
    {
        private readonly INotifier _notifier;
        public SlackNotifier(INotifier notifier1) { _notifier = notifier1; }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Slack {message}");
        }
    }
Client will inject INotifier and called notifier.Send("Hello"); it will send Email,Sms,Slack
//For console app testing do like below
    INotifier notifier = new EmailNotifier();
    notifier = new SmsNotifier(notifier);
    notifier = new SlackNotifier(notifier);
    notifier.Send("System alert!");
Another approach for Decorator pattern using abstract class, only difference is SMS, Slack not required to hold the reference of the base initialized via constructor
    public interface INotifier
    {
        void Send(string message);
    }
    public class EmailNotifier : INotifier
    {
        public void Send(string message)
        {
            Console.WriteLine($"Email {message}");
        }
    }
    public abstract class NotifierDecorator : INotifier
    {
        protected readonly INotifier _notifier;
        public NotifierDecorator(INotifier notifier) { _notifier = notifier; }
        public void Send(string message)
        { //dummy
        }
    }
    public class SmsNotifier : NotifierDecorator
    {

        public SmsNotifier(INotifier notifier) : base(notifier)
        {
        }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Sms {message}");
        }
    }
    public class SlackNotifier : NotifierDecorator
    {

        public SlackNotifier(INotifier notifier) : base(notifier)
        {
        }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Slack {message}");
        }
    }    

#ClassVsStruct
    var employer1 = new Employer { Name = "Google", Age = 50, Country = new Country { Name = "USA" } };
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 50, Country: USA
    var employer2 = employer1;
    employer2.Age = 30;  //
    Console.WriteLine(employer2.ToString()); //Name: Google, Age: 30, Country: USA
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 30, Country: USA
    employer2.Country = new Country { Name = "India" };
    Console.WriteLine(employer2.ToString()); //Name: Google, Age: 30, Country: India
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 30, Country: India



    var employerStruct1 = new EmployerStruct { Name = "Google", Age = 50, Country = new Country { Name = "USA" } };
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: USA
    var employerStruct2 = employerStruct1;
    employerStruct2.Age = 30;
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: USA
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: USA
    employerStruct2.Country.Name = "India";
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: India
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: India
    employerStruct2.Country = new Country { Name = "Canada" };
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: Canada
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: India

#Spread
Spreading Arrays
    string[] first = ["A", "B"];
    string[] second = ["C", "D"];
    string[] result = [..first, ..second];    // earlier -> first.contact(second).ToArray(); or Array.Copy or add to List -> AddRange
    // => ["A", "B", "C", "D"]
Spreading LINQ results
    List<string> words = ["HELLO", "world", "BYE"];
    string[] capitals = [.. words.Where(w => w.ToUpper() == w)];
    // => ["HELLO", "BYE"]
Spreading with literals
    int[] baseNumbers = [2, 3];
    int[] all = [1, ..baseNumbers, 4, 5];
    // => [1, 2, 3, 4, 5]


#OrderBy
    public static void OrderBy()
    {
        var animals = new List<Animal>();
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "johnny", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "sally", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "Alexa", });
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "sandra", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "Sunny", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "feebie", });
        var sortedAnimals = animals.OrderBy(a => a.Type).ThenBy(a => a.Name);
        Console.WriteLine(string.Join(Environment.NewLine, sortedAnimals.Select(a => new { a.Type, a.Name})));
    }
Output: (notice, first sorted by AnimalType and then by Name within that Animal Type)
    { Type = Dog, Name = johnny }
    { Type = Dog, Name = sandra }
    { Type = Cat, Name = Alexa }
    { Type = Cat, Name = sally }
    { Type = Bird, Name = feebie }
    { Type = Bird, Name = Sunny }

#OrderByWithFirst
    public static string FindShortestWord(List<string> words)
    {
        return words.OrderBy(w => w.Length).First();
    }
#WhereWithIndex
    public static void WhereWithIndex()
    {
        var animals = new List<Animal>();
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "johnny", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "sally", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "Alexa", });
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "sandra", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "Sunny", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "feebie", });
        var evenAnimals = animals.Where((a, index) => index % 2 == 0);
        Console.WriteLine(string.Join(Environment.NewLine, evenAnimals.Select(a => new { a.Type, a.Name })));
    }

#StaticMemoryLeak
    public class CacheLeak
    {
        // Static list lives for the entire program
        private static List<byte[]> _cache = new List<byte[]>();

        public void AddData()
        {
            // 10 MB block added on every call
            _cache.Add(new byte[10 * 1024 * 1024]);
        }
    }
Why this leaks:
_cache is static → it is never collected.
Every call to AddData adds another 10 MB chunk.
Even if the calling objects go out of scope, _cache still holds references, preventing GC from freeing the memory.

#StreamWriter
    Option1:
        StreamWriter streamWriter = new StreamWriter(@"c:\test\log.txt");
        streamWriter.WriteLine("line1");
        streamWriter.WriteLine("line2");
        streamWriter.Flush();
    Option2:
        using (StreamWriter streamWriter = new StreamWriter(@"c:\test\log.txt"))
        {
            streamWriter.WriteLine("line1");
            streamWriter.WriteLine("line2");
        }

        public override void Close()
        {
            Dispose(true);
        }
        protected override void Dispose(bool disposing)
        {
            if (disposing)
                Flush();   // flush buffer

            // Release base stream (FileStream)
            base.Dispose(disposing);
        }


#Attributes
    var animal1 = new Animal1("Sunny",2);
    var animal2 = new Animal1("ph", 2);

    ObjectNameLengthValidator objectNameLengthValidator = new ObjectNameLengthValidator();
    objectNameLengthValidator.Validate(animal1);
    objectNameLengthValidator.Validate(animal2);
    public class Animal1
    {
        public int Age { get; }

        [StringLength(5, 10)]
        public string Name { get;}

        public Animal1(string name, int age)
        {   
            this.Age = age;
            this.Name = name;
        }
    }

    [AttributeUsage(AttributeTargets.Property)]  //Allows attributes to be used only on properties
    public class  StringLengthAttribute: Attribute
    {
        public int Max { get; }
        public int Min { get; }

        public StringLengthAttribute(int min, int max) {
            this.Min = min;
            this.Max = max;
        }
    }
    public class ObjectNameLengthValidator {
        public void Validate(object obj) {
            var stringLengthAttributedProperties = obj.GetType().GetProperties().Where(p => Attribute.IsDefined(p, typeof(StringLengthAttribute)));
            foreach (var property in stringLengthAttributedProperties) {
                var attribute = property.GetCustomAttributes(typeof(StringLengthAttribute), true).FirstOrDefault() as StringLengthAttribute;
                var stringValue = property.GetValue(obj) as string;
                if(stringValue.Length < attribute.Min || stringValue.Length > attribute.Max) {
                    Console.WriteLine($"Error: {obj.GetType().Name} {property.GetValue(obj)} has an invalid length of {stringValue.Length}");
                }
                
            }

        }
    }

#Equals
public struct Cartesian : IEquatable<Cartesian>
{
    public int X { get; set; }
    public int Y { get; set; }

    public Cartesian(int x, int y)
    {
        X = x;
        Y = y;
    }

    public override bool Equals(object? obj) => obj is Cartesian other && X == other.X && Y == other.Y; //this is used when the object is passed as a parameter
    public bool Equals(Cartesian other) => X == other.X && Y == other.Y; //used when cartesian1.Equals(cartesian2)
    public static bool operator ==(Cartesian left, Cartesian right) => left.Equals(right);  //used when cartesian1 == cartesian2
    public static bool operator !=(Cartesian left, Cartesian right) => !left.Equals(right); //used when cartesian1 != cartesian2
    public static Cartesian operator +(Cartesian left, Cartesian right) => new Cartesian(left.X + right.X, left.Y + right.Y); //add two cartesian and return new cartesian
    public override int GetHashCode() => HashCode.Combine(X, Y); // This is required when we override Equals
}

#implicitoperator
Pointer pointer = (2, 5);
public struct Pointer
{
    public int X { get; set; }
    public int Y { get; set; }
    public Pointer(int x, int y)
    {
        X = x;
        Y = y;
    }
    public static implicit operator Pointer((int x, int y) point) => new Pointer(point.x, point.y);
    //if explicit used then Pointer pointer = (Pointer)(2,5); should be the syntax
}

#CustomHash
    public class Person : IEquatable<Person>
    {
        public int YearOfBirth { get; set; }
        public string Name { get; set; }

        public bool Equals(Person? other)
        {
            return other.Name == this.Name && other.YearOfBirth == this.YearOfBirth;
        }
        public override bool Equals(object? obj)
        {
            return Equals(obj as Person);
        }
        public override int GetHashCode() => HashCode.Combine(Name, YearOfBirth);
    }

#Record
    public record WeatherData1(decimal Temperature, int Humidity);
    //if not record you will endup writing as below
     public class WeatherData: IEquatable<WeatherData>
        {
            public decimal Temperature { get; set; }
            public int Humidity { get; set; }
            public WeatherData(decimal temperature, int humidity)
            {
                Temperature = temperature;
                Humidity = humidity;
            }
            public override string ToString() => $"Temperature: {Temperature} Humidity: {Humidity}";

            public override bool Equals(object? obj) => Equals(obj as WeatherData); 
            public bool Equals(WeatherData other) => Temperature == other.Temperature && Humidity == other.Humidity;

            public override int GetHashCode()
            {
                return HashCode.Combine(Temperature, Humidity);
            }
            public static bool operator ==(WeatherData left, WeatherData right) => EqualityComparer<WeatherData>.Default.Equals(left, right);

            public static bool operator !=(WeatherData left, WeatherData right) => !(left == right);
        }

#CustomCollection
    var customCollection = new CustomCollection(new string[] { "Sunny", "Phoebe" });
    var enumerator = customCollection.GetEnumerator();
    while (enumerator.MoveNext())
    {
        Console.WriteLine(enumerator.Current);
    }
    public class CustomCollection : IEnumerable
    {
        public string[] Words { get; }
        public CustomCollection(string[] words)
        {
            Words = words;
        }

        public IEnumerator GetEnumerator()
        {
            return new WordsEnumerator(Words);
        }
    }

    public class WordsEnumerator : IEnumerator
    {
        public object Current
        {
            get
            {
                return _words[_currentIndex];
            }
        }

        private int _currentIndex = -1;
        private readonly string[] _words;


        public WordsEnumerator(string[] words)
        {
            _words = words;
        }

        public bool MoveNext()
        {
            _currentIndex++;
            if (_currentIndex > _words.Length-1) return false;
            return true;
        }

        public void Reset()
        {
            _currentIndex = -1;
        }
    }
    
#ImplicitExplicitInterface 

//Generic -> calling implicit interface member: IEnumerator<string> GetEnumerator()
var customCollection = new CustomCollection(new string[] { "Sunny", "Phoebe" });
var enumerator = customCollection.GetEnumerator();
while (enumerator.MoveNext())
{
    Console.WriteLine(enumerator.Current); //this will call object public string Current => _words[_currentIndex];
}

//Non generic calling explicit interface  IEnumerator IEnumerable.GetEnumerator()
IEnumerable customCollection2 = new CustomCollection(new string[] { "Sunny", "Phoebe" });
var enumerator2 = customCollection2.GetEnumerator();
while (enumerator2.MoveNext())
{
    Console.WriteLine(enumerator2.Current);  //this will call object IEnumerator.Current => _words[_currentIndex];
}

public class CustomCollection : IEnumerable<string>
{
    private readonly string[] words;
    public CustomCollection(string[] words)
    {
        this.words = words;
    }
    //implicit interface
    public IEnumerator<string> GetEnumerator() { 
            return new StringWordsEnumerator(words);
            //instead of above line WordsEnumerator, we can use yield which returns an Iterator
            // foreach(var word in Words) yield return word;
            //or use Enumerator from generic IEnumerable
            //IEnumerable<string> words = Words;
            //return words.GetEnumerator();

    }
    
    IEnumerator IEnumerable.GetEnumerator() => new StringWordsEnumerator(words);
}

public class StringWordsEnumerator : IEnumerator<string>
{
    private readonly string[] _words;
    private int _currentIndex = -1;
    public StringWordsEnumerator(string[] words) { _words = words; }

    public string Current => _words[_currentIndex];

    object IEnumerator.Current => _words[_currentIndex];

    public bool MoveNext()
    {
        _currentIndex++;
        if (_currentIndex > _words.Length - 1) return false;
        return true;
    }

    public void Dispose() { }
    public void Reset() {_currentIndex = -1;}
}

#Indexer
    PairOfArrays<int, string> pairOfArrays = new(new int[] { 0, 2, 3 }, new string[] { "Suny", "Phoebe" });
    pairOfArrays[0,0] = (1, "Sunny"); //Note here when setting a value we are passing a tuple and inside indexer we access it by value.Item1, value.Item2
    Console.WriteLine(pairOfArrays[0,0]); //output: (1, Sunny)
    
    public class PairOfArrays<TLeft, TRight>
    {
        private readonly TLeft[] _left;
        private readonly TRight[] _right;

        public PairOfArrays(
            TLeft[] left, TRight[] right)
        {
            _left = left;
            _right = right;
        }

        public (TLeft, TRight) this[int tLeftIndex, int tRightIndex]
        {
            get
            {
                if (tLeftIndex > _left.Length - 1 || tRightIndex > _right.Length - 1) throw new IndexOutOfRangeException();
                return (_left[tLeftIndex], _right[tRightIndex]);
            }
            set
            {
                if (tLeftIndex > _left.Length - 1 || tRightIndex > _right.Length - 1) throw new IndexOutOfRangeException();
                _left[tLeftIndex] = value.Item1; _right[tRightIndex] = value.Item2;
            }
        }
    }

#CollectionInitializer
CollectionInitializer collectionInitializer = new CollectionInitializer { "Sunny", "Phoebe" };
Console.WriteLine(string.Join(",", collectionInitializer.Words)); //output: Sunny Phoebe

public class CollectionInitializer: IEnumerable {

    public string[] Words { get; set; }
    private int _index = 0;
    public CollectionInitializer() { Words = new string[10]; }

    public void Add(string word) { 
        Words[_index] = word;
        _index++;
    }

    public IEnumerator GetEnumerator()
    {
        throw new NotImplementedException();
    }
}     

#BinarySearch
    public static int FindIndexByBinarySearch(this List<int> list, int value) {
        int leftIndex = 0;
        int rightIndex = list.Count - 1;
        while (leftIndex <= rightIndex) {
            var middleIndex = (leftIndex + rightIndex) / 2;
            if (list[middleIndex] == value) return middleIndex;  
            if (list[middleIndex] > value) rightIndex = middleIndex - 1; else leftIndex = middleIndex + 1;
            //above equivalent using CompareTo if (list[middleIndex].CompareTo(value) > 0) rightIndex = middleIndex - 1; else leftIndex = middleIndex + 1;
        }
        return -1;
    }

#Yield
//Take few numbers than actual exist
YieldSample yieldSample = new YieldSample();
IEnumerable<int> numbers = yieldSample.GetNumbers();
foreach (int number in numbers)
{
    Console.WriteLine($"Consuming {number}");
}
// Read only few lines from a large set of data
var fileLines = yieldSample.ReadLargeFile();
foreach (var line in fileLines.Take(2))
{
    Console.WriteLine($"File content: {line}");
}

//Fibonacci series 0,1,1,2,3 (each number is the sum of two preciding numbers)
var fibonacciSeriesIterator = yieldSample.GetFibonacciSeries();
foreach (var number in fibonacciSeriesIterator.Take(10))
{
    Console.WriteLine($"Fibonacci number: {number}");
}

//Multiple yields 
foreach(var word in  yieldSample.GetMultipleYields()){ 
    Console.WriteLine(word);
}
//output: 
hello
world

//yield values in reverse until first null encountered
var reversedValuesUntilNull = yieldSample.GetAllAfterLastNullReversed(new string[] { "a", "b", null, "d", "e", "f"});
foreach (var value in reversedValuesUntilNull)
{
    Console.WriteLine($"Consuming {value}");
}
//output:
Consuming f
Consuming e
Consuming d

public class YieldSample {
    public IEnumerable<int> GetNumbers() {
        for (int i = 0; i < 4; i++)
        {
            Console.WriteLine($"Yielding {i}");
            yield return i;
        }
    }

    public IEnumerable<string> ReadLargeFile()
    {
        string? line;
        using var reader = new StreamReader(@"c:\logs\largefile.txt") ;
        while((line = reader.ReadLine())!=null) {
            yield return line;
        }
    }

    //note here after yield return we have the statements, those gets executed after every yield
    public IEnumerable<long> GetFibonacciSeries() {
        long a=0, b=1;
        while (true) { 
            yield return a;
            var c = a + b;
            a = b; b = c;
        }
    }

    //multiple yields, when iterated after one yield is done, next yield is returned 
    public IEnumerable<string> GetMultipleYields() {
        yield return "hello";
        yield return "world";
    }
    
    //yields values in reverse until first null encounted
        public IEnumerable<T> GetAllAfterLastNullReversed<T>(IList<T> input)
        {
            foreach (var item in input.Reverse()) { 
                if(item != null) yield return item;
                else yield break;
            }
        }                

}

#YieldBreak
YieldSample yieldSample = new YieldSample();
var numbersBeforeFirstNegative = yieldSample.GetAllNumbersBeforeFirstNegative(new[] { 1, 2, 4, 5, 6, 12, 2, -1, 5, 6, 7 });
foreach (var number in numbersBeforeFirstNegative)
{
    Console.WriteLine($"Consuming {number}");
}
    public class YieldSample {
      public IEnumerable<int> GetAllNumbersBeforeFirstNegative(IEnumerable<int> numbers) {
          foreach (var number in numbers) {
              if(number >= 0) yield return number;
              else yield break;
              Console.WriteLine($"Yielding {number}");
          }
      }
  }
output:
    Consuming 1
    Yielding 1
    Consuming 2
    Yielding 2
    Consuming 4
    Yielding 4
    Consuming 5
    Yielding 5
    Consuming 6
    Yielding 6
    Consuming 12
    Yielding 12
    Consuming 2
    Yielding 2  

#IEnumerableInterface  

var customCollection = new CustomCollection(new string[] { "Sunny", "Phoebe" });
foreach (var word in customCollection)
{
    Console.WriteLine(word);
}
//output: Sunny Phoebe
public class CustomCollection : IEnumerable<string>
{
    private readonly string[] _words;
    public CustomCollection1(string[] words)
    {
        _words = words;
    }
    //implicit interface
    public IEnumerator<string> GetEnumerator() { 

        foreach (var word in _words) yield return word;
        //or use Enumerator from generic IEnumerable
        //IEnumerable<string> words = _words;
        //return words.GetEnumerator();

    }
   IEnumerator IEnumerable.GetEnumerator() => _words.GetEnumerator();
} 

#ManualThread
    var iterations = 100;
    var threadSample = new ThreadSample();

    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();
    for(int i = 0; i < iterations; i++)
    {
        var thread = new Thread(threadSample.Print);
        thread.Start();
    }
    stopwatch.Stop();
    Console.WriteLine("Time elapsed: {0}ms", stopwatch.ElapsedMilliseconds);
    //roughly takes 1130 ms
    public class ThreadSample
    {
        private int _counter = 0;
        public void Print(object obj)
        {
            int count = Interlocked.Increment(ref _counter);
            Console.Write($"{count}:{Thread.CurrentThread.ManagedThreadId} ");
        }
    }

    switch to ThreadPool, roughly takes 78ms
    var iterations = 100;
    var threadSample = new ThreadSample();

    Stopwatch stopwatch = new Stopwatch();
    stopwatch.Start();public class ThreadSample
{
    public void PrintPlus(int iterations)
    {
        for(int i = 0; i < iterations; i++)
        Console.Write($"+:{Thread.CurrentThread.ManagedThreadId} ");
    }
    public void PrintMinus(int iterations)
    {
        for (int i = 0; i < iterations; i++)
            Console.Write($"+:{Thread.CurrentThread.ManagedThreadId} ");
    }
}
    CountdownEvent countdownEvent  = new CountdownEvent(iterations);
    for(int i = 0; i < iterations; i++)
    {
        ThreadPool.QueueUserWorkItem(_ => { threadSample.Print(null); 
            countdownEvent.Signal();  // <-- SIGNAL AFTER work finishes
        });
        ThreadPool.QueueUserWorkItem(threadSample.Print); 
    }
    countdownEvent.Wait();
    stopwatch.Stop();
    Console.WriteLine("Time elapsed: {0}ms", stopwatch.ElapsedMilliseconds);

#Task
Running multiple unit of work (task)  using Task instead of Thread
var threadSample = new ThreadSample();
Stopwatch stopwatch = new Stopwatch();
stopwatch.Start();
CountdownEvent countdownEvent  = new CountdownEvent(iterations);
Task task1 = Task.Factory.StartNew(() => threadSample.PrintPlus(100));
Task task2 = Task.Run(() => threadSample.PrintMinus(100));
//older approach  Task task3 = new Task(() => threadSample.PrintPlus(100)); task3.Start();
stopwatch.Stop();
Console.WriteLine("Time elapsed: {0}ms", stopwatch.ElapsedMilliseconds);

public class ThreadSample
{
    public void PrintPlus(int iterations)
    {
        for(int i = 0; i < iterations; i++)
        Console.Write($"+:{Thread.CurrentThread.ManagedThreadId} ");
    }
    public void PrintMinus(int iterations)
    {
        for (int i = 0; i < iterations; i++)
            Console.Write($"+:{Thread.CurrentThread.ManagedThreadId} ");
    }
}    

#TaskContinue
var result = TaskContinueSample.FormatSquaredNumbersFrom1To(5);
Console.WriteLine(result.Result); //output: 1, 4, 9, 16, 25
public class TaskContinueSample
{
    public static Task<string> FormatSquaredNumbersFrom1To(int n)
    {
        if (n < 0) throw new ArgumentException("n must be greater than 0");
        if (n == 0) return Task.FromResult(string.Empty);
        Task<int>[] tasks = new Task<int>[n];
        for (int i = 1; i <= n; i++)
        {
            var variableCopy = i;
            tasks[i - 1] = Task.Run(() => variableCopy * variableCopy);
        }
        Task<string> continuationTask = Task.Factory.ContinueWhenAll(tasks, tasks => string.Join(", ", tasks.Select(t => t.Result)));
        return continuationTask;
    }
}

#CancellationToken
When the user types cancel CancellationToken is cancelled and NeverEndingMethod quits
CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
Task task = Task.Run(() => TaskCancellationSample.NeverEndingMethod(cancellationTokenSource), cancellationTokenSource.Token);

string userInput = string.Empty;
do
{
    userInput = Console.ReadLine();
    if(userInput == "cancel") cancellationTokenSource.Cancel();
}
while (cancellationTokenSource.IsCancellationRequested == false);

Thread.Sleep(1000);
Console.WriteLine("End of program");
public class TaskCancellationSample
{
    public static void NeverEndingMethod(CancellationTokenSource cancellationTokenSource) {
        do {
            Console.WriteLine("Working...");
            Thread.Sleep(3000);
        } while (cancellationTokenSource.IsCancellationRequested == false);
    }
}

#OperationCancelledException
CancellationTokenSource cancellationTokenSource= new CancellationTokenSource();
Task task = Task.Run(() => TaskCancellationSample.NeverEndingMethod(cancellationTokenSource), cancellationTokenSource.Token);

string userInput = string.Empty;
do
{
    userInput = Console.ReadLine();
    if(userInput == "cancel") cancellationTokenSource.Cancel();
}
while (cancellationTokenSource.IsCancellationRequested == false);

Thread.Sleep(5000);
Console.WriteLine("End of program");
    public class TaskCancellationSample
    {
        public static void NeverEndingMethod(CancellationTokenSource cancellationTokenSource) {
            do {
                Console.WriteLine("Working...");
                Thread.Sleep(3000);
                cancellationTokenSource.Token.ThrowIfCancellationRequested();
               // or equivalent if(cancellationTokenSource.IsCancellationRequested) throw new OperationCanceledException(cancellationTokenSource.Token);
            } while (true);
        }
    }

#AggregateException
Task taskResult = AggregateExceptionSample.Test(null);
Thread.Sleep(3000);
while (true) { 
    Console.WriteLine("Working");
    Thread.Sleep(1000);
}
 public class AggregateExceptionSample
 {
     public static float? Divide(int? x, int? y)
     {
         if (x == null || y == null) throw new ArgumentNullException("Argument cannot be null");
         if (y == 0) throw new DivideByZeroException("Divisor cannot be zero");

         return x / (float)y;  //cast one of the operand as float to get decimal value, either divident or divisor
         throw new Exception("Exception in MethodThrowsException");
     }

     public static Task Test(string? input)
     {
         var task = Task.Run(() => ParseToIntAndPrint(input))
          .ContinueWith(faultedTask => faultedTask.Exception.Handle(exception =>  
          {
              if (exception is ArgumentNullException)
              {
                  Console.WriteLine("The input is null.");
                  return true;
              }
              else if (exception is FormatException)
              {
                  Console.WriteLine("The input is not in a correct format.");
                  return true;
              }
              else if (exception is ArgumentOutOfRangeException)
              {
                  Console.WriteLine("Unexpected exception type.");
                  return false;
              }
              return false;
          }));
         return task;
     }
     private static void ParseToIntAndPrint(string? input)
     {
         if (input is null)
         {
             throw new ArgumentNullException();
         }

         if (long.TryParse(input, out long result))
         {
             if (result > int.MaxValue)
             {
                 throw new ArgumentOutOfRangeException("The number is too big for an int.");
             }
             Console.WriteLine("Parsing successful, the result is: " + result);
         }
         else
         {
             throw new FormatException();
         }
     }
 }