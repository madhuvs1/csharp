#CustomGenerics
        public class ListOfInt {

            private int[] _intArray = new int[IntArraySize];
            public static int IntArraySize { get; set; } = 4;
            private int _freeIndex = 0;

            public void Add(int x) {
                if (_freeIndex > IntArraySize - 1)
                {
                    var tempArray = new int[IntArraySize * 2];
                    for (int i = 0; i < IntArraySize; i++)
                    {
                        tempArray[i] = _intArray[i];
                    }
                    IntArraySize = IntArraySize * 2;
                    _intArray = tempArray;
                }
                _intArray[_freeIndex++] = x;
            }
            public void RemoveAt(int x) {
                if(x >= _freeIndex) throw new ArgumentException(nameof(x));
                for (int i = x; i < _freeIndex-1; i++) {
                    _intArray[i] = _intArray[i+1] ;
                }
                _freeIndex--;
            }
            public int GetAtIndex(int index) {
                return _intArray[index];
            }
        }
usage: 
    ListOfInt listOfInt = new ListOfInt();
    listOfInt.Add(1);
    listOfInt.Add(2);
    var intValueAtIndex5 = listOfInt.GetAtIndex(5);
    listOfInt.RemoveAt(4);        

#SimpleGenericType
    public class Pair<T> {
        public T First{get;private set;}
        public T Second{get; private set;}
        public Pair(T first, T second){
            First = first;
            Second = second;
        }
        public void ResetFirst(){
            First = default(T);
        }
        
        public void ResetSecond(){
            Second = default(T);
        }
    }
usage: var pair = new Pair<string, string>("hello", "world");            

#GenericMethod
    public class NonGeneric
    {
        public void Add<T>(T obj)
        {
            Console.WriteLine(typeof(T));
        }
    }
    public static class ListExtension
    {
        public static List<TTarget> ConvertTo<TSource, TTarget>(this List<TSource> input) where TSource : class  where TTarget : class
        {
            var newList = new List<TTarget>();
            foreach (var item in input)
            {
                if(item is TTarget target)
                    newList.Add(target);
            }
            return newList;
        }
    }

#Tuple
    public static class TupleSwapExercise
    {
        //new way
        public static (T2, T1) SwapTupleItems1<T1, T2>((T1 param1, T2 param2) item)
        {
            return (item.param2, item.param1);
        }
        public static (T2, T1) SwapTupleItems2<T1, T2>((T1, T2) item) { 
            return (item.Item2, item.Item1);
        }
        //legacy way
        public static Tuple<T2, T1> SwapTupleItemsOld<T1, T2>(Tuple<T1, T2> tuple) {
            return new Tuple<T2,T1>(tuple.Item2, tuple.Item1);
        }
    }

#Invariant
class Person { }
class Employee : Person { }
List<Employee> employees = new List<Employee>();
List<Person> persons = employees; // ❌ Error — List<T> is invariant


#Covariance
Detailed example:
Scenario, you need to get list of Animals from shelter and print them. As you see a generic provider (IAnimalProvider) has ability to get all types of animals. For an interface to 
achieve this that can take parent type(animal) and allow its derived types you have to define a Generic Interface using out keyword (generic modifier) AND method should not take 
generic parameter T as input, rather it should only return T (producer not consumer)
public static class AnimalChecker
{
    public static void PrintAnimals(IAnimalProvider<Animal> provider)
    {
        while (true)
        {
            var animal = provider.GetNext();
            if (animal == null) return;
            Console.WriteLine(animal.Name);
        }
    }
}
Lets create the Interface with out generic modifier
public interface IAnimalProvider<out T> {
	public T GetNext(); //Note here T is returned not consumed that's a rule for Covariance
}

Now define templates for Animal and its derived ones Dog and Cat
	public class Animal
	{
		public string Name { get; set; }
		public virtual void Sound() { Console.WriteLine("Animal Sound"); }
	}
	public class Dog : Animal
	{
		public override void Sound() { Console.WriteLine("Bow Bow"); }
	}
	public class Cat : Animal
	{
		public override void Sound() { Console.WriteLine("Meow Meow"); }
	}

Now to satisfy PrintAnimals lets make derive from Covariant Generic interface
	public class DogProvider : IAnimalProvider<Dog>
	{
		private readonly Queue<Dog> _dogs = new Queue<Dog>();
		public DogProvider()
		{
			_dogs.Enqueue(new Dog { Name = "Rex" });

			_dogs.Enqueue(new Dog { Name = "Buddy" });

		}
		public Dog GetNext()
		{
			return _dogs.Count > 0 ? _dogs.Dequeue() : null;
		}
	}
One more for Cat lets make derive from Covariant Generic interface
	public class CatProvider : IAnimalProvider<Cat>
	{
		private readonly Queue<Cat> _cats = new Queue<Cat>();
		public CatProvider()
		{
			_cats.Enqueue(new Cat { Name = "Lexie" });

			_cats.Enqueue(new Cat { Name = "Scarlet" });

		}

		public Cat GetNext()
		{
			return _cats.Count > 0 ? _cats.Dequeue() : null;
		}
	}

With this setup, different providers holding subtypes(dog, cat) can be substitued for Animal generic parameter
	AnimalChecker.PrintAnimals(new DogProvider());
	AnimalChecker.PrintAnimals(new CatProvider());
output: 	
	Rex
	Buddy
	Lexie
	Scarlet

--------
    public class Person {}
    public class Employee: Person {}
    public interface IDataProvider<out T> { T GetData(); }
    public class EmployeeDataProvider: IDataProvider<Employee> {
        public Employee GetData(){}
    }
    IDataProvider<Person> person = new EmployeeDataProvider();

#Contravariance
    public class Person{}
    public class Employee{}
    public interface  IDataSaver<in T>{ void Save(T data) }
    public class PersonDataSaver: IDataSaver<Person>{
        public void Save(Person data);
    }
    IDataSaver<Employee> dataSaver = new PersonDataSaver();
    dataSaver.Save(new Employee());

#IComparable
    public class Person: IComparable<Person> { 
        public int YearOfBirth { get; set; }
        public string Name { get; set; }
        public int CompareTo(Person other) {
            if (this.YearOfBirth < other.YearOfBirth) return -1; //(1940 < 1950)  meaning this.YearOfBirth(1940) stays in front and other.YearOfBirth(1950) moved to last
            else if(this.YearOfBirth > other.YearOfBirth) return 1; //reverse of above
            return 0; //no change to the list
        }
    }
    Another usecase to sort names first by lastname and then firstname
    public class SortedList<T> where T: IComparable<T>
    {
        public IEnumerable<T> Items { get; }

        public SortedList(IEnumerable<T> items)
        {
            var asList = items.ToList();
            asList.Sort();
            Items = asList;
        }
    }

    public class FullName: IComparable<FullName>
    {
        public string FirstName { get; init; }
        public string LastName { get; init; }

        public override string ToString() => $"{FirstName} {LastName}";

        public int CompareTo(FullName other)
        {
            if (other.LastName == LastName) {
                return FirstName.CompareTo(other.FirstName);
            }
            return LastName.CompareTo(other.LastName);
        }
    }

#Func
//Inline func example
    Func<string, int> stringLength = x => x.Length;
    Console.WriteLine(stringLength("HelloWorld"));
    Func<int, int, int> sumOfTwoNumbers = (x, y) => x + y;
    Console.WriteLine(sumOfTwoNumbers(1,1));
//Assign func to an existing method
    Func<int, int, int> Func1 = Add;
    public int Add(int a, int b) => a+b;
//Func as parameter to class you pass implementation to method param
    FuncClass funcClass = new FuncClass();
    Console.WriteLine(funcClass.FuncMethod(x => x.Length));
        public class FuncClass {
        public int FuncMethod(Func<string, int> func) => func("HelloWorld");
    }
//Func as class level fields    
    public class Exercise
    {
        public Func<string, int> GetLength = (x) => x.Length;
        public Func<int> GetRandomNumberBetween1And10 = () => new Random().Next(2, 10);
    }
#delegates
    public string TrimTo5Letters(string input){return input.Substring(0,5);}
    public string ToUpper(string input) {return input.ToUpper();}
    delegate string StringProcessor(string input);
    StringProcessor stringProcessor1 = TrimTo5Letters;
    StringProcessor stringProcessor2 = ToUpper;
    Console.WriteLine(stringProcessor1("HelloWorld"));
    Console.WriteLine(stringProcessor2("HelloWorld"));
Multicast delegate:
    public class DelegateBench {
        public void TrimTo5Letters(string input) { Console.WriteLine(input.Substring(0, 5)); }
        public void ToUpper(string input) { Console.WriteLine(input.ToUpper()); }
        public delegate void StringProcessor(string input);

        public void Test()
        {
            StringProcessor stringProcessor1 = TrimTo5Letters;
            StringProcessor stringProcessor2 = ToUpper;
            StringProcessor stringProcessor = stringProcessor1 + stringProcessor2;
            StringProcessor stringProcessor3 = x => Console.WriteLine(x.ToLower());
            stringProcessor += stringProcessor3;
            stringProcessor("HelloWorld");
        }
    }
    DelegateBench delegateBench = new DelegateBench();
    delegateBench.Test();

#event
    public class TravelVideos
    {
        // Event to notify when a new video is uploaded
        public event Action<string> VideoUploaded;

        // Called when a new video is added
        public void UploadVideo(string videoTitle)
        {
            Console.WriteLine($"[Publisher] Uploading new travel video: {videoTitle}");

            // Notify all subscribers safely
            VideoUploaded?.Invoke(videoTitle);
        }
    }

    public class EmailService
    {
        private string _subscriberEmail;
        public EmailService(string subscriberEmail)
        {
            _subscriberEmail = subscriberEmail;
        }
        public void SendEmailNotification(string videoTitle) =>
           Console.WriteLine($"[Email] Sent to {_subscriberEmail}: New video → {videoTitle}");
    }


startup.cs
    var travelVideos = new TravelVideos();

    // 3 subscribers, each with different email addresses
    var subscriber1 = new EmailService("alice@example.com");
    var subscriber2 = new EmailService("bob@example.com");
    var subscriber3 = new EmailService("charlie@example.com");

    // All three subscribe to the event
    travelVideos.VideoUploaded += subscriber1.SendEmailNotification;
    travelVideos.VideoUploaded += subscriber2.SendEmailNotification;
    travelVideos.VideoUploaded += subscriber3.SendEmailNotification;

Event Trigger when the video upload event occurs
    travelVideos.UploadVideo("Switzerland Skiing");

Output: 
    [Publisher] New travel video uploaded: Switzerland Skiing
    [Email] Sent to alice@example.com: New video → Switzerland Skiing
    [Email] Sent to bob@example.com: New video → Switzerland Skiing
    [Email] Sent to charlie@example.com: New video → Switzerland Skiing





#Dictionary
    Dicationary<string,string> countriesAndCurrency = new Dictionary<string,string>();
    countriesAndCurrency["USA]="USD"
    Initialize Dictionary with multiple key values
    Dicationary<string,string> countriesAndCurrency = new Dictionary<string,string> {
        ["USA"] = "USD",
        ["India"] = "INR"
        ["Spain"] = "EUR"
    }
   
    public static class Exercise
    {
        public static Dictionary<PetType, double> FindMaxWeights(List<Pet> pets)
        {
            //using linq groupby return pets.GroupBy(x => x.PetType).ToDictionary(g => g.Key, g => g.Max(p=> p.Weight));
            Dictionary<PetType, double> petsWithMaxWeight = new Dictionary<PetType, double>();
            foreach (Pet pet in pets) {
               var petsByType = pets.FindAll(x => x.PetType == pet.PetType);
                petsWithMaxWeight[pet.PetType] = petsByType.Max<Pet>(x => x.Weight);  
            }
            return petsWithMaxWeight;
        }
    }

#StrategyDesignPattern
    Example1: Strategy pattern using interface
    public interface IPaymentStrategy { void pay(); }
    public PayPal: IPaymentStrategy{ public void Pay() {Console.WriteLine("Processing PayPal payment");} }
    public CreditCard: IPaymentStrategy{ public void Pay() {Console.WriteLine("Processing CreditCard payment");} }
    public class OrderService {
        public void ProcessPayment(IPaymentStrategy paymentStrategy){
            paymentStrategy.Pay();
        }
    }
    Example2: Strategy pattern using Function Delegates
    public class StrategySelector
    {
        public static Predicate<int> SelectStrategy(string userInput)
        {
            return userInput switch
            {
                "even" => x => x % 2 == 0,
                "odd" => x => x % 2 == 1,
                "positive" => x => x > 0,
                "negative" => x => x < 0,
                _ => throw new InvalidOperationException("Invalid user choice")
            };
        }
    }

    public class NumbersFilter
    {
        public static List<int> Filter(Predicate<int> func, List<int> numbers)
        {
            var filteredList = new List<int>();
            foreach (int i in numbers)
            {
                if (func(i)) filteredList.Add(i);
            }
            return filteredList;
        }
    }
    var userInput = Console.ReadLine();
    var strategy = StrategySelector.SelectStrategy(userInput);
    var numbers = new List<int> { -3, -2, -1, 0, 1, 2, 3, 4, 5, 6 };
    var filteredNumbers = NumbersFilter.Filter(strategy, numbers);
    Console.WriteLine(string.Join(",", filteredNumbers));

#Decorator Pattern
    services.AddTransient<INotifier>(sp =>
    {
        INotifier n = new EmailNotifier();
        n = new SMSNotifier(n);
        n = new SlackNotifier(n);
        return n;
    });
    public interface INotifier
    {
        void Send(string message);
    }
    public class EmailNotifier : INotifier
    {
        public void Send(string message)
        {
            Console.WriteLine($"Email {message}");
        }
    }

    public class SmsNotifier : INotifier
    {
        private readonly INotifier _notifier;
        public SmsNotifier(INotifier notifier) { _notifier = notifier; }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Sms {message}");
        }
    }

    public class SlackNotifier : INotifier
    {
        private readonly INotifier _notifier;
        public SlackNotifier(INotifier notifier1) { _notifier = notifier1; }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Slack {message}");
        }
    }
Client will inject INotifier and called notifier.Send("Hello"); it will send Email,Sms,Slack
//For console app testing do like below
    INotifier notifier = new EmailNotifier();
    notifier = new SmsNotifier(notifier);
    notifier = new SlackNotifier(notifier);
    notifier.Send("System alert!");
Another approach for Decorator pattern using abstract class, only difference is SMS, Slack not required to hold the reference of the base initialized via constructor
    public interface INotifier
    {
        void Send(string message);
    }
    public class EmailNotifier : INotifier
    {
        public void Send(string message)
        {
            Console.WriteLine($"Email {message}");
        }
    }
    public abstract class NotifierDecorator : INotifier
    {
        protected readonly INotifier _notifier;
        public NotifierDecorator(INotifier notifier) { _notifier = notifier; }
        public void Send(string message)
        { //dummy
        }
    }
    public class SmsNotifier : NotifierDecorator
    {

        public SmsNotifier(INotifier notifier) : base(notifier)
        {
        }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Sms {message}");
        }
    }
    public class SlackNotifier : NotifierDecorator
    {

        public SlackNotifier(INotifier notifier) : base(notifier)
        {
        }
        public void Send(string message)
        {
            _notifier.Send(message);
            Console.WriteLine($"Slack {message}");
        }
    }    

#ClassVsStruct
    var employer1 = new Employer { Name = "Google", Age = 50, Country = new Country { Name = "USA" } };
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 50, Country: USA
    var employer2 = employer1;
    employer2.Age = 30;  //
    Console.WriteLine(employer2.ToString()); //Name: Google, Age: 30, Country: USA
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 30, Country: USA
    employer2.Country = new Country { Name = "India" };
    Console.WriteLine(employer2.ToString()); //Name: Google, Age: 30, Country: India
    Console.WriteLine(employer1.ToString()); //Name: Google, Age: 30, Country: India



    var employerStruct1 = new EmployerStruct { Name = "Google", Age = 50, Country = new Country { Name = "USA" } };
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: USA
    var employerStruct2 = employerStruct1;
    employerStruct2.Age = 30;
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: USA
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: USA
    employerStruct2.Country.Name = "India";
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: India
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: India
    employerStruct2.Country = new Country { Name = "Canada" };
    Console.WriteLine(employerStruct2.ToString()); //Name: Google, Age: 30, Country: Canada
    Console.WriteLine(employerStruct1.ToString()); //Name: Google, Age: 50, Country: India

#Spread
Spreading Arrays
    string[] first = ["A", "B"];
    string[] second = ["C", "D"];
    string[] result = [..first, ..second];    // earlier -> first.contact(second).ToArray(); or Array.Copy or add to List -> AddRange
    // => ["A", "B", "C", "D"]
Spreading LINQ results
    List<string> words = ["HELLO", "world", "BYE"];
    string[] capitals = [.. words.Where(w => w.ToUpper() == w)];
    // => ["HELLO", "BYE"]
Spreading with literals
    int[] baseNumbers = [2, 3];
    int[] all = [1, ..baseNumbers, 4, 5];
    // => [1, 2, 3, 4, 5]


#OrderBy
    public static void OrderBy()
    {
        var animals = new List<Animal>();
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "johnny", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "sally", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "Alexa", });
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "sandra", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "Sunny", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "feebie", });
        var sortedAnimals = animals.OrderBy(a => a.Type).ThenBy(a => a.Name);
        Console.WriteLine(string.Join(Environment.NewLine, sortedAnimals.Select(a => new { a.Type, a.Name})));
    }
Output: (notice, first sorted by AnimalType and then by Name within that Animal Type)
    { Type = Dog, Name = johnny }
    { Type = Dog, Name = sandra }
    { Type = Cat, Name = Alexa }
    { Type = Cat, Name = sally }
    { Type = Bird, Name = feebie }
    { Type = Bird, Name = Sunny }

#OrderByWithFirst
    public static string FindShortestWord(List<string> words)
    {
        return words.OrderBy(w => w.Length).First();
    }
#WhereWithIndex
    public static void WhereWithIndex()
    {
        var animals = new List<Animal>();
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "johnny", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "sally", });
        animals.Add(new Animal { Type = AnimalType.Cat, Name = "Alexa", });
        animals.Add(new Animal { Type = AnimalType.Dog, Name = "sandra", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "Sunny", });
        animals.Add(new Animal { Type = AnimalType.Bird, Name = "feebie", });
        var evenAnimals = animals.Where((a, index) => index % 2 == 0);
        Console.WriteLine(string.Join(Environment.NewLine, evenAnimals.Select(a => new { a.Type, a.Name })));
    }

#StaticMemoryLeak
    public class CacheLeak
    {
        // Static list lives for the entire program
        private static List<byte[]> _cache = new List<byte[]>();

        public void AddData()
        {
            // 10 MB block added on every call
            _cache.Add(new byte[10 * 1024 * 1024]);
        }
    }
Why this leaks:
_cache is static → it is never collected.
Every call to AddData adds another 10 MB chunk.
Even if the calling objects go out of scope, _cache still holds references, preventing GC from freeing the memory.

#StreamWriter
    Option1:
        StreamWriter streamWriter = new StreamWriter(@"c:\test\log.txt");
        streamWriter.WriteLine("line1");
        streamWriter.WriteLine("line2");
        streamWriter.Flush();
    Option2:
        using (StreamWriter streamWriter = new StreamWriter(@"c:\test\log.txt"))
        {
            streamWriter.WriteLine("line1");
            streamWriter.WriteLine("line2");
        }

        public override void Close()
        {
            Dispose(true);
        }
        protected override void Dispose(bool disposing)
        {
            if (disposing)
                Flush();   // flush buffer

            // Release base stream (FileStream)
            base.Dispose(disposing);
        }


#Attributes
    var animal1 = new Animal1("Sunny",2);
    var animal2 = new Animal1("ph", 2);

    ObjectNameLengthValidator objectNameLengthValidator = new ObjectNameLengthValidator();
    objectNameLengthValidator.Validate(animal1);
    objectNameLengthValidator.Validate(animal2);
    public class Animal1
    {
        public int Age { get; }

        [StringLength(5, 10)]
        public string Name { get;}

        public Animal1(string name, int age)
        {   
            this.Age = age;
            this.Name = name;
        }
    }

    [AttributeUsage(AttributeTargets.Property)]  //Allows attributes to be used only on properties
    public class  StringLengthAttribute: Attribute
    {
        public int Max { get; }
        public int Min { get; }

        public StringLengthAttribute(int min, int max) {
            this.Min = min;
            this.Max = max;
        }
    }
    public class ObjectNameLengthValidator {
        public void Validate(object obj) {
            var stringLengthAttributedProperties = obj.GetType().GetProperties().Where(p => Attribute.IsDefined(p, typeof(StringLengthAttribute)));
            foreach (var property in stringLengthAttributedProperties) {
                var attribute = property.GetCustomAttributes(typeof(StringLengthAttribute), true).FirstOrDefault() as StringLengthAttribute;
                var stringValue = property.GetValue(obj) as string;
                if(stringValue.Length < attribute.Min || stringValue.Length > attribute.Max) {
                    Console.WriteLine($"Error: {obj.GetType().Name} {property.GetValue(obj)} has an invalid length of {stringValue.Length}");
                }
                
            }

        }
    }

#Equals
public struct Cartesian : IEquatable<Cartesian>
{
    public int X { get; set; }
    public int Y { get; set; }

    public Cartesian(int x, int y)
    {
        X = x;
        Y = y;
    }

    public override bool Equals(object? obj) => obj is Cartesian other && X == other.X && Y == other.Y; //this is used when the object is passed as a parameter
    public bool Equals(Cartesian other) => X == other.X && Y == other.Y; //used when cartesian1.Equals(cartesian2)
    public static bool operator ==(Cartesian left, Cartesian right) => left.Equals(right);  //used when cartesian1 == cartesian2
    public static bool operator !=(Cartesian left, Cartesian right) => !left.Equals(right); //used when cartesian1 != cartesian2
    public static Cartesian operator +(Cartesian left, Cartesian right) => new Cartesian(left.X + right.X, left.Y + right.Y); //add two cartesian and return new cartesian
    public override int GetHashCode() => HashCode.Combine(X, Y); // This is required when we override Equals
}

#implicitoperator
Pointer pointer = (2, 5);
public struct Pointer
{
    public int X { get; set; }
    public int Y { get; set; }
    public Pointer(int x, int y)
    {
        X = x;
        Y = y;
    }
    public static implicit operator Pointer((int x, int y) point) => new Pointer(point.x, point.y);
    //if explicit used then Pointer pointer = (Pointer)(2,5); should be the syntax
}

#CustomHash
    public class Person : IEquatable<Person>
    {
        public int YearOfBirth { get; set; }
        public string Name { get; set; }

        public bool Equals(Person? other)
        {
            return other.Name == this.Name && other.YearOfBirth == this.YearOfBirth;
        }
        public override bool Equals(object? obj)
        {
            return Equals(obj as Person);
        }
        public override int GetHashCode() => HashCode.Combine(Name, YearOfBirth);
    }

#Record
    public record WeatherData1(decimal Temperature, int Humidity);
    //if not record you will endup writing as below
     public class WeatherData: IEquatable<WeatherData>
        {
            public decimal Temperature { get; set; }
            public int Humidity { get; set; }
            public WeatherData(decimal temperature, int humidity)
            {
                Temperature = temperature;
                Humidity = humidity;
            }
            public override string ToString() => $"Temperature: {Temperature} Humidity: {Humidity}";

            public override bool Equals(object? obj) => Equals(obj as WeatherData); 
            public bool Equals(WeatherData other) => Temperature == other.Temperature && Humidity == other.Humidity;

            public override int GetHashCode()
            {
                return HashCode.Combine(Temperature, Humidity);
            }
            public static bool operator ==(WeatherData left, WeatherData right) => EqualityComparer<WeatherData>.Default.Equals(left, right);

            public static bool operator !=(WeatherData left, WeatherData right) => !(left == right);
        }

#CustomCollection
    public class CustomCollection : IEnumerable
    {
        public string[] Words { get; }
        public CustomCollection(string[] words)
        {
            Words = words;
        }

        public IEnumerator GetEnumerator()
        {
            return new WordsEnumerator(Words);
        }
    }

    public class WordsEnumerator : IEnumerator
    {
        public object Current
        {
            get
            {
                return _words[_currentIndex];
            }
        }

        private int _currentIndex = -1;
        private readonly string[] _words;


        public WordsEnumerator(string[] words)
        {
            _words = words;
        }

        public bool MoveNext()
        {
            _currentIndex++;
            if (_currentIndex > _words.Length-1) return false;
            return true;
        }

        public void Reset()
        {
            _currentIndex = -1;
        }
    }
    